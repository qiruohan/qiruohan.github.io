<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Litgod&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://litgod.net/"/>
  <updated>2020-06-20T08:21:08.932Z</updated>
  <id>https://litgod.net/</id>
  
  <author>
    <name>齐小神</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>深拷贝与浅拷贝</title>
    <link href="https://litgod.net/2020/06/18/%E6%B7%B1%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B5%85%E6%8B%B7%E8%B4%9D/"/>
    <id>https://litgod.net/2020/06/18/%E6%B7%B1%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B5%85%E6%8B%B7%E8%B4%9D/</id>
    <published>2020-06-18T09:47:43.000Z</published>
    <updated>2020-06-20T08:21:08.932Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/uploads/veer-333382587.jpg" alt="image"></p><a id="more"></a><p>这是一道经典的面试题，相信大多数同学都有被面试官问过的经历，那么你能实现几种深拷贝和浅拷贝的方法？让我们来一起总结常用的深浅拷贝（克隆）的方法吧！</p><h2 id="开始之前"><a href="#开始之前" class="headerlink" title="开始之前"></a>开始之前</h2><p>在开始之前，我们要先明确一下 JS 的数据类型，以及数据存储（栈和堆）的概念：</p><ul><li>JS 数据类型分为<strong>基本数据类型</strong>和<strong>引用数据类型</strong>（引用数据类型又称复杂数据类型）</li></ul><table><thead><tr><th>基本数据类型</th><th align="center">引用数据类型</th></tr></thead><tbody><tr><td>Number</td><td align="center">Object</td></tr><tr><td>String</td><td align="center">Function</td></tr><tr><td>Boolean</td><td align="center">Array</td></tr><tr><td>Undefind</td><td align="center">Date</td></tr><tr><td>Null</td><td align="center">RegExp</td></tr><tr><td>Symbol（ES6 新增）</td><td align="center">Math</td></tr><tr><td>BigInt（ES10 新增）</td><td align="center">…都是Object类型的实例对象</td></tr></tbody></table><ul><li>基本数据类型和引用数据类型的储存方式区别：</li></ul><p>基本数据类型：变量名和值都储存在栈内存中；<br>引用数据类型：变量名储存在<strong>栈内存</strong>中，值储存在<strong>堆内存</strong>中，堆内存中会提供一个引用地址指向堆内存中的值，而这个引用地址是储存在栈内存中的。</p><p>例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    a: <span class="number">100</span>,</span><br><span class="line">    b: <span class="string">'name'</span>,</span><br><span class="line">    c:[<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>],</span><br><span class="line">    d:&#123;</span><br><span class="line">        x:<span class="number">10</span></span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>obj 在内存中的储存如下：</p><table><thead><tr><th>栈内存</th><th align="center">栈内存</th><th align="right">堆内存</th></tr></thead><tbody><tr><td>name</td><td align="center">val</td><td align="right">val</td></tr><tr><td>a</td><td align="center">100</td><td align="right">—</td></tr><tr><td>b</td><td align="center">‘name’</td><td align="right">—</td></tr><tr><td>c</td><td align="center">AAAFFF000（一个引用地址，指向堆内存的值）</td><td align="right">[10,20,30]</td></tr><tr><td>d</td><td align="center">BBBFFF000（一个引用地址，指向堆内存的值）</td><td align="right">{ x:10 }</td></tr></tbody></table><p>对这几个概念有了初步了解之后，接下来正式开始讲深浅拷贝。</p><h2 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h2><p>何为浅拷贝？当 obj2 拷贝了 obj 的数据，且当 obj2 的改变会导致 obj 的改变时，此时叫 obj2 浅拷贝了 obj。</p><p>举个例子1：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    a: <span class="string">'100'</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj2 = obj;</span><br><span class="line">obj2.a = <span class="string">'200'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(obj.a)    <span class="comment">// '200'</span></span><br></pre></td></tr></table></figure><p>obj 直接赋值给 obj2 后，obj2 中 a 属性的改变导致了 obj 中 a 属性也发生了变化。</p><p>其实这里的原因也很简单，因为这种赋值方式只是将 obj 的堆内存地址赋值给了 obj2，<strong>obj 和 obj2 指向的是一个存储地址</strong>，是同一个内容，因此 obj2 的改变当然会引起 obj 的改变。</p><h3 id="常见的浅拷贝"><a href="#常见的浅拷贝" class="headerlink" title="常见的浅拷贝"></a>常见的浅拷贝</h3><p>我们以下面的对象为例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    a: <span class="string">'100'</span>,</span><br><span class="line">    b: <span class="literal">undefined</span>,</span><br><span class="line">    c: <span class="literal">null</span>,</span><br><span class="line">    d: <span class="built_in">Symbol</span>(<span class="number">2</span>),</span><br><span class="line">    e: <span class="regexp">/^\d+$/</span>,</span><br><span class="line">    f: <span class="keyword">new</span> <span class="built_in">Date</span>,</span><br><span class="line">    g: <span class="literal">true</span>,</span><br><span class="line">    arr:[<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>],</span><br><span class="line">    school:&#123;</span><br><span class="line">        name:<span class="string">'cherry'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    fn: <span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'fn'</span>);    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方法一：直接赋值"><a href="#方法一：直接赋值" class="headerlink" title="方法一：直接赋值"></a>方法一：直接赋值</h3><p>直接赋值的方法就是我们刚才所举的例子1，这种方式实现的就是纯粹的浅拷贝，obj2 的任何变化都会反映在 obj 上。</p><h3 id="方法二：使用对象的解构"><a href="#方法二：使用对象的解构" class="headerlink" title="方法二：使用对象的解构"></a>方法二：使用对象的解构</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj2 = &#123; ...obj &#125;</span><br></pre></td></tr></table></figure><h3 id="方法三：使用循环"><a href="#方法三：使用循环" class="headerlink" title="方法三：使用循环"></a>方法三：使用循环</h3><p>对象循环我们使用 <strong>for in</strong> 循环，但<strong>for in</strong> 循环会遍历到对象的继承属性，我们只需要它的私有属性，所以可以加一个判断方法：<strong>hasOwnProperty</strong> 保留对象私有属性。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj2 = &#123;&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i <span class="keyword">in</span> obj) &#123;</span><br><span class="line">    <span class="keyword">if</span>(!obj.hasOwnProperty(i)) <span class="keyword">break</span>; <span class="comment">// 这里使用 continue 也可以</span></span><br><span class="line">    obj2[i] = obj[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方法四：Object-assign-target-source"><a href="#方法四：Object-assign-target-source" class="headerlink" title="方法四：Object.assign(target,source)"></a>方法四：Object.assign(target,source)</h3><p>这是ES6中新增的对象方法，对它不了解的见<a href="https://es6.ruanyifeng.com/" target="_blank" rel="external nofollow noopener noreferrer">ES6</a>对象新增方法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj2 = &#123;&#125;;</span><br><span class="line"><span class="built_in">Object</span>.assign(obj2,obj); <span class="comment">//将 obj 拷贝到 obj2</span></span><br></pre></td></tr></table></figure><h2 id="浅拷贝总结："><a href="#浅拷贝总结：" class="headerlink" title="浅拷贝总结："></a>浅拷贝总结：</h2><p>方法一：就是纯粹的浅拷贝，obj2 的任何变化都会反映在 obj 上。<br>方法二、三、四：都可以实现<strong>第一层的“深拷贝”</strong>，但无法实现多层的深拷贝。比如我们修改下 obj2 的值：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">obj2.a = <span class="string">'200'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(obj.a);  <span class="comment">// '100'</span></span><br><span class="line"><span class="comment">// obj.a 属性未发生变化</span></span><br><span class="line"></span><br><span class="line">obj2.school.name = <span class="string">'susan'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(obj.school.name);  <span class="comment">// 'sucan'</span></span><br><span class="line"><span class="comment">// obj.school.name 属性随着 obj2 而变化了</span></span><br></pre></td></tr></table></figure><p>这几种拷贝方法无法满足更深层级的拷贝，所以我们需要另一种万全之策–<strong>深拷贝</strong>。</p><h2 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h2><h3 id="方法一：JSON-parse-和JSON-stringify"><a href="#方法一：JSON-parse-和JSON-stringify" class="headerlink" title="方法一：JSON.parse()和JSON.stringify"></a>方法一：JSON.parse()和JSON.stringify</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj2 = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(obj));</span><br><span class="line"></span><br><span class="line">obj2.schoole.name= <span class="string">'susan'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(obj.school.name); <span class="comment">// 'cherry'</span></span><br><span class="line"><span class="comment">//obj 中属性值并没有改变,说明是深拷贝</span></span><br></pre></td></tr></table></figure><p>这种方法是比较简单的深拷贝，在对象属性的类型比较简单的时候，我们可以采取这种方法快速深拷贝。</p><p>但当对象属性的类型较为复杂时，就会发现这种方法虽然能实现深拷贝，但也有很多坑，运行上面的代码后发现：</p><ul><li>值为 undefined 的属性在转换后丢失；</li><li>值为 Symbol 类型的属性在转换后丢失；</li><li>值为 RegExp 对象的属性在转换后变成了空对象；</li><li>值为 函数对象的属性在转换后丢失；</li><li>值为 Date 对象的属性在转换后变成了字符串；</li><li>会抛弃对象的 constructor,所有的构造函数会指向 Object；</li><li>对象的循环引用会抛出错误。</li></ul><p>最后两种坑，我们来简单测试下：</p><ul><li><p>会抛弃对象的 constructor,所有的构造函数会指向 Object</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Cherry = <span class="keyword">new</span> person(<span class="string">'Cherry'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    a: Cherry,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> obj2 = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(obj));</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(obj.a.constructor, obj2.a.constructor); <span class="comment">// [Function: person] [Function: Object]</span></span><br></pre></td></tr></table></figure></li><li><p>对象的循环引用会抛出错误</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;&#125;;</span><br><span class="line">obj.a = obj;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj2 = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(obj)); <span class="comment">// TypeError: Converting circular structure to JSON</span></span><br></pre></td></tr></table></figure></li></ul><p>是不是觉得坑很多？所以小伙伴们在使用这种方式深拷贝的时候，还是要多多注意下。<br>出现这种问题的原因和 <strong>JSON.stringify 方法的序列化</strong>规则有关系，关于JSON.stringify序列化的具体规则见 JSON.stringify 指南。</p><p>下面引用了其他文档中对JSON.stringify序列化规则的描述，供大家参考：</p><blockquote><p>对大多数简单值来说，JSON字符串化和toString()的效果基本相同，只不过序列化的结果总是字符串：</p><p>JSON.stringify(42);  // “42”<br>JSON.stringify(“42”);  // “”42””(含有双引号的字符串)<br>JSON.stringify(null);  // “null”<br>JSON.stringify(true);  // “true”</p><p>所有安全的JSON值（JSON-safe）都可以使用JSON.stringify(…)字符串化。安全的JSON值是指能够呈现为有效JSON格式的值。</p><p>为了简单起见，我们来看看什么是不安全的JSON值。undefined、function、symbol（ES6+）和包含循环引用（对象之前相互引用，形成一个无限循环）的对象都不符合JSON结构标准，其他支持JSON的语言无法处理它们。</p><p>JSON.stringify(…)在对象中遇到undefined、function和symbol时会自动将其忽略，在数组中则会返回null（以保证单元位置不变）。</p><p>例如：<br>JSON.stringify(undefined);  //undefined<br>JSON.stringify(function(){});  //undefined</p><p>JSON.stringify(<br>[1,undefined,function(){},4]<br>);     //“[1, null, null, 4]”</p><p>JSON.stringify(<br>  {a:2, b: function(){}}<br>);     //“{“a”: 2}”</p><p>对包含循环引用的对象执行JSON.stringify(…); 会报错。</p></blockquote><p>关于<strong>如何去 JSON.stringify 序列化</strong>也是一个比较有意思的问题，大家可以学习一下，毕竟面试官总是喜欢问到你不会为止。。。</p><h3 id="方法二：手写-deepClone"><a href="#方法二：手写-deepClone" class="headerlink" title="方法二：手写 deepClone"></a>方法二：手写 deepClone</h3><p>既然第一种方法有它的弊端，那最终极的方法，就是手写一个 deepClone 了。</p><p>用过<code>lodash</code>的小伙伴都知道<code>lodash</code>提供了<code>_.cloneDeep</code> 方法深克隆，想看 lodash 实现源码的可以点击<a href="https://github.com/lodash/lodash/blob/master/cloneDeep.js" target="_blank" rel="external nofollow noopener noreferrer">这里</a>，它的源码里实现的比较复杂，考虑的情况比较多，我们写一个简单版的深拷贝可以在自己项目中使用即可。</p><p>简单的实现思路：<br>1.遍历带拷贝的对象，判断是不是原始值，若是，使用浅拷贝的方式进行赋值<br>2.若是引用值，将特殊类型逐一进行过滤，并且兼容引用值是数组的情况<br>3.待拷贝的对象里面的若是原始值，则浅拷贝即可实现，若还有引用值，则还需要重复进行上述一系列的判断。（递归赋值）</p><p>上述思路用代码如何实现呢？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    a: <span class="string">'100'</span>,</span><br><span class="line">    b: <span class="literal">undefined</span>,</span><br><span class="line">    c: <span class="literal">null</span>,</span><br><span class="line">    d: <span class="built_in">Symbol</span>(<span class="number">2</span>),</span><br><span class="line">    e: <span class="regexp">/^\d+$/</span>,</span><br><span class="line">    f: <span class="keyword">new</span> <span class="built_in">Date</span>,</span><br><span class="line">    g: <span class="literal">true</span>,</span><br><span class="line">    arr: [<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>],</span><br><span class="line">    school:&#123;</span><br><span class="line">        name: <span class="string">'cherry'</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    fn: <span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'fn'</span>);    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepClone</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 先把特殊情况全部过滤掉 null undefined date reg</span></span><br><span class="line">    <span class="keyword">if</span> (obj == <span class="literal">null</span>) <span class="keyword">return</span> obj;  <span class="comment">// null 和 undefined 都不用处理</span></span><br><span class="line">    <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> <span class="built_in">Date</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Date</span>(obj);</span><br><span class="line">    <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> <span class="built_in">RegExp</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">RegExp</span>(obj);</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> obj !== <span class="string">'object'</span>) <span class="keyword">return</span> obj;  <span class="comment">// 普通常量直接返回</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不直接创建空对象的目的：克隆的结果和之前保持相同的所属类，</span></span><br><span class="line">    <span class="comment">// 同时也兼容了数组的情况</span></span><br><span class="line">    <span class="keyword">let</span> newObj = <span class="keyword">new</span> obj.constructor;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">        <span class="keyword">if</span> (obj.hasOwnProperty(key)) &#123;  <span class="comment">// 不拷贝原型链上的属性</span></span><br><span class="line">            newObj[key] = deepClone(obj[key]);  <span class="comment">// 递归赋值</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newObj;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> obj2 = deepClone(obj);</span><br><span class="line"><span class="built_in">console</span>.log(obj2);</span><br></pre></td></tr></table></figure><p>执行代码，得到 obj2 的结果和 obj 一致，且属性值的改变彼此互不影响。</p><blockquote><p>Q：为什么 type null 会返回 object ？<br>A：因为在 js 的设计中，object的前三位标志是000，而 null 在32位表示中也全是0，因此，<code>typeof null</code> 也会打印出<code>object</code>。</p></blockquote><p>代码写到这里，我们就实现了一种比较简单的深拷贝，面试的时候如果你能写出上面的实现方法，应该算是及格啦！但是，面对复杂的，多类型的对象，以上方法还是有诸多缺陷的。</p><p>比如我们为 <code>obj</code> 中的 <code>school</code> 对象添加一个 <code>Symbol</code> 类型的属性：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//==新增代码==</span></span><br><span class="line"><span class="keyword">let</span> s1 = <span class="built_in">Symbol</span>(<span class="string">'s1'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    a: <span class="string">'100'</span>,</span><br><span class="line">    b: <span class="literal">undefined</span>,</span><br><span class="line">    c: <span class="literal">null</span>,</span><br><span class="line">    d: <span class="built_in">Symbol</span>(<span class="number">2</span>),</span><br><span class="line">    e: <span class="regexp">/^\d+$/</span>,</span><br><span class="line">    f: <span class="keyword">new</span> <span class="built_in">Date</span>,</span><br><span class="line">    g: <span class="literal">true</span>,</span><br><span class="line">    arr: [<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>],</span><br><span class="line">    school:&#123;</span><br><span class="line">        name: <span class="string">'cherry'</span>,</span><br><span class="line">        <span class="comment">//==新增代码==</span></span><br><span class="line">        [s1]: <span class="string">'s1'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    fn: <span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'fn'</span>);    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> obj2 = deepClone(obj);</span><br><span class="line"><span class="built_in">console</span>.log(obj2);</span><br></pre></td></tr></table></figure><p>执行代码后发现 <code>school</code> 中的 <code>Symbol(s1): &#39;s1&#39;</code>并没有拷贝成功。这是因为声明对象的 key 为 symbol 类型是不可枚举的，要解决这个问题，我们可以使用 Object 提供的 <code>getOwnPrepertySymbols()</code>方法来枚举对象中所有 key 是 symbol 类型的属性，这个属性的详细使用说明参见 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertySymbols" target="_blank" rel="external nofollow noopener noreferrer">MDN</a>，或者用<code>Reflect.ownKeys()</code>。</p><p>还比如：如果在我们拷贝的对象被循环引用，deepClone就会一直执行下去导致爆栈，举个例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    a: <span class="string">'100'</span>,</span><br><span class="line">    b: <span class="literal">undefined</span>,</span><br><span class="line">    c: <span class="literal">null</span>,</span><br><span class="line">    d: <span class="built_in">Symbol</span>(<span class="number">2</span>),</span><br><span class="line">    e: <span class="regexp">/^\d+$/</span>,</span><br><span class="line">    f: <span class="keyword">new</span> <span class="built_in">Date</span>,</span><br><span class="line">    g: <span class="literal">true</span>,</span><br><span class="line">    arr: [<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>],</span><br><span class="line">    school:&#123;</span><br><span class="line">        name: <span class="string">'cherry'</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    fn: <span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'fn'</span>);    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj.h = obj;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj2 = deepClone(obj);</span><br><span class="line"><span class="built_in">console</span>.log(obj2);</span><br></pre></td></tr></table></figure><p>执行上述代码后，控制台抛出栈溢出错误：<code>Maximum call stack size exceeded</code>。其实解决循环引用的思路，就是在赋值之前判断当前值是否已经存在，避免循环引用，这里我们可以使用 es6 的 WeakMap 来生成一个 hash 表。</p><p>针对以上这两个问题，我们来优化一下代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s1 = <span class="built_in">Symbol</span>(<span class="string">'s1'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    a: <span class="string">'100'</span>,</span><br><span class="line">    b: <span class="literal">undefined</span>,</span><br><span class="line">    c: <span class="literal">null</span>,</span><br><span class="line">    d: <span class="built_in">Symbol</span>(<span class="number">2</span>),</span><br><span class="line">    e: <span class="regexp">/^\d+$/</span>,</span><br><span class="line">    f: <span class="keyword">new</span> <span class="built_in">Date</span>,</span><br><span class="line">    g: <span class="literal">true</span>,</span><br><span class="line">    arr: [<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>],</span><br><span class="line">    school:&#123;</span><br><span class="line">        name:<span class="string">'cherry'</span>,</span><br><span class="line">        [s1]: <span class="string">'s1'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    fn: <span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'fn'</span>);    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj.h = obj;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepClone</span>(<span class="params">obj, hash = new WeakMap(</span>)) </span>&#123;</span><br><span class="line">    <span class="comment">//先把特殊情况全部过滤掉 null undefined date reg</span></span><br><span class="line">    <span class="keyword">if</span> (obj == <span class="literal">null</span>) <span class="keyword">return</span> obj;  <span class="comment">//null 和 undefined 都不用处理</span></span><br><span class="line">    <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> <span class="built_in">Date</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Date</span>(obj);</span><br><span class="line">    <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> <span class="built_in">RegExp</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">RegExp</span>(obj);</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> obj !== <span class="string">'object'</span>) <span class="keyword">return</span> obj;  <span class="comment">// 普通常量直接返回</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//  防止对象中的循环引用爆栈，把拷贝过的对象直接返还即可</span></span><br><span class="line">    <span class="keyword">if</span> (hash.has(obj)) <span class="keyword">return</span> hash.get(obj);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不直接创建空对象的目的：克隆的结果和之前保持相同的所属类</span></span><br><span class="line">    <span class="comment">// 同时也兼容了数组的情况</span></span><br><span class="line">    <span class="keyword">let</span> newObj = <span class="keyword">new</span> obj.constructor;</span><br><span class="line"></span><br><span class="line">    hash.set(obj, newObj)  <span class="comment">// 制作一个映射表</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//判断是否有 key 为 symbol 的属性</span></span><br><span class="line">    <span class="keyword">let</span> symKeys = <span class="built_in">Object</span>.getOwnPropertySymbols(obj);</span><br><span class="line">    <span class="keyword">if</span> (symKeys.length) &#123; </span><br><span class="line">        symKeys.forEach(<span class="function"><span class="params">symKey</span> =&gt;</span> &#123;</span><br><span class="line">            newObj[symKey] = deepClone(obj[symKey], hash);   </span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">        <span class="keyword">if</span> (obj.hasOwnProperty(key)) &#123;  <span class="comment">// 不拷贝原型链上的属性</span></span><br><span class="line">            newObj[key] = deepClone(obj[key], hash);  <span class="comment">// 递归赋值</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newObj;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> obj2 = deepClone(obj);</span><br><span class="line"><span class="built_in">console</span>.log(obj2);</span><br></pre></td></tr></table></figure><p>这样，一个比较完善的深拷贝就实现啦～</p><p>不过，完善但不是完美，还有更高维度的问题需要优化，比如：1.没有考虑 es6 中 Map 和 Set 的拷贝，2.递归消耗大量的内存会导致的爆栈等等等等，想要实现一个完美的深拷贝，还是有很多内容需要我们深度学习～</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>如果你还对深拷贝有兴趣或者想研究，可以阅读lodash 深拷贝相关代码，相信你会对深拷贝有进一步的理解～</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/uploads/veer-333382587.jpg&quot; alt=&quot;image&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>重排(reflow)和重绘(repaint)</title>
    <link href="https://litgod.net/2020/01/30/%E9%87%8D%E7%BB%98%E5%92%8C%E9%87%8D%E6%8E%92/"/>
    <id>https://litgod.net/2020/01/30/%E9%87%8D%E7%BB%98%E5%92%8C%E9%87%8D%E6%8E%92/</id>
    <published>2020-01-30T14:48:22.000Z</published>
    <updated>2020-06-18T10:36:00.507Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/uploads/i3_1.jpg" alt="image"></p><a id="more"></a><p>test</p><p>之前面试的大佬问我关于重排重绘的原理和具体操作，一下子把我问蒙了。回家便默默地把问题记下来，仔细总结……在阅读了一些文章后，自己也有了一定的理解，所以分享给大家。希望大家也能耐心把这篇文章看完，认真思考，彻底掌握这个知识点！</p><h2 id="页面生成的过程："><a href="#页面生成的过程：" class="headerlink" title="页面生成的过程："></a>页面生成的过程：</h2><p>1.HTML 被 HTML 解析器解析成 DOM 树；<br>2.CSS  被 CSS 解析器解析成 CSSOM 树；<br>3.结合 DOM 树和 CSSOM 树，生成一棵渲染树(Render Tree)，这一过程称为 Attachment；<br>4.生成布局(flow)，浏览器在屏幕上“画”出渲染树中的所有节点；<br>5.将布局绘制(paint)在屏幕上，显示出整个页面。</p><p>第四步和第五步是最耗时的部分，这两步合起来，就是我们通常所说的渲染。</p><p><img src="/uploads/i3_2.png" alt="image"></p><h2 id="渲染："><a href="#渲染：" class="headerlink" title="渲染："></a>渲染：</h2><p>在页面的生命周期中，<strong>网页生成的时候，至少会渲染一次</strong>。<strong>在用户访问的过程中，还会不断触发重排(reflow)和重绘(repaint)</strong>，不管页面发生了重绘还是重排，都会影响性能，<strong>最可怕的是重排，会使我们付出高额的性能代价，所以我们应尽量避免</strong>。</p><h2 id="重排比重绘大："><a href="#重排比重绘大：" class="headerlink" title="重排比重绘大："></a>重排比重绘大：</h2><p>大，在这个语境里的意思是：谁能影响谁？</p><ul><li>重绘：某些元素的外观被改变，例如：元素的填充颜色</li><li>重排：重新生成布局，重新排列元素。</li></ul><p>就如上面的概念一样，单单改变元素的外观，肯定不会引起网页重新生成布局，但当浏览器完成重排之后，将会重新绘制受到此次重排影响的部分。比如改变元素高度，这个元素乃至周边dom都需要重新绘制。</p><p>也就是说：<strong>重绘不一定导致重排，但重排一定会导致重绘</strong>。</p><h2 id="重排-reflow-："><a href="#重排-reflow-：" class="headerlink" title="重排(reflow)："></a>重排(reflow)：</h2><h3 id="概念："><a href="#概念：" class="headerlink" title="概念："></a>概念：</h3><p>当DOM的变化影响了元素的几何信息(元素的的位置和尺寸大小)，浏览器需要重新计算元素的几何属性，将其安放在界面中的正确位置，这个过程叫做重排。</p><p>重排也叫回流，简单的说就是重新生成布局，重新排列元素。</p><h3 id="下面情况会发生重排："><a href="#下面情况会发生重排：" class="headerlink" title="下面情况会发生重排："></a>下面情况会发生重排：</h3><ul><li>页面初始渲染，这是开销最大的一次重排</li><li>添加/删除可见的DOM元素</li><li>改变元素位置</li><li>改变元素尺寸，比如边距、填充、边框、宽度和高度等</li><li>改变元素内容，比如文字数量，图片大小等</li><li>改变元素字体大小</li><li>改变浏览器窗口尺寸，比如resize事件发生时</li><li>激活CSS伪类（例如：<code>:hover</code>）</li><li>设置 style 属性的值，因为通过设置style属性改变结点样式的话，每一次设置都会触发一次reflow</li><li>查询某些属性或调用某些计算方法：offsetWidth、offsetHeight等，除此之外，当我们调用 <code>getComputedStyle</code>方法，或者IE里的 <code>currentStyle</code> 时，也会触发重排，原理是一样的，都为求一个“即时性”和“准确性”。</li></ul><table><thead><tr><th>常见引起重排属性和方法</th><th align="center">–</th><th align="right">–</th><th align="right">–</th></tr></thead><tbody><tr><td>width</td><td align="center">height</td><td align="right">margin</td><td align="right">padding</td></tr><tr><td>display</td><td align="center">border-width</td><td align="right">border</td><td align="right">position</td></tr><tr><td>overflow</td><td align="center">font-size</td><td align="right">vertical-align</td><td align="right">min-height</td></tr><tr><td>clientWidth</td><td align="center">clientHeight</td><td align="right">clientTop</td><td align="right">clientLeft</td></tr><tr><td>offsetWudth</td><td align="center">offsetHeight</td><td align="right">offsetTop</td><td align="right">offsetLeft</td></tr><tr><td>scrollWidth</td><td align="center">scrollHeight</td><td align="right">scrollTop</td><td align="right">scrollLeft</td></tr><tr><td>scrollIntoView()</td><td align="center">scrollTo()</td><td align="right">getComputedStyle()</td><td align="right"></td></tr><tr><td>getBoundingClientRect()</td><td align="center">scrollIntoViewIfNeeded()</td><td align="right"></td><td align="right"></td></tr></tbody></table><h3 id="重排影响的范围："><a href="#重排影响的范围：" class="headerlink" title="重排影响的范围："></a>重排影响的范围：</h3><p>由于浏览器渲染界面是基于流失布局模型的，所以触发重排时会对周围DOM重新排列，影响的范围有两种：</p><ul><li>全局范围：从根节点html开始对整个渲染树进行重新布局。</li><li>局部范围：对渲染树的某部分或某一个渲染对象进行重新布局</li></ul><p><strong>全局范围重排：</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"hello"</span>&gt;</span><br><span class="line">    &lt;h4&gt;hello&lt;<span class="regexp">/h4&gt;</span></span><br><span class="line"><span class="regexp">    &lt;p&gt;&lt;strong&gt;Name:&lt;/</span>strong&gt;BDing&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">    &lt;h5&gt;male&lt;/</span>h5&gt;</span><br><span class="line">    &lt;ol&gt;</span><br><span class="line">      &lt;li&gt;coding&lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">      &lt;li&gt;loving&lt;/</span>li&gt;</span><br><span class="line">    &lt;<span class="regexp">/ol&gt;</span></span><br><span class="line"><span class="regexp">  &lt;/</span>div&gt;</span><br><span class="line">&lt;<span class="regexp">/body&gt;</span></span><br></pre></td></tr></table></figure><p>当p节点上发生reflow时，hello和body也会重新渲染，甚至h5和ol都会收到影响。</p><p><strong>局部范围重排：</strong></p><p>用局部布局来解释这种现象：把一个dom的宽高之类的几何信息定死，然后在dom内部触发重排，就只会重新渲染该dom内部的元素，而不会影响到外界。</p><h2 id="重绘-Repaints"><a href="#重绘-Repaints" class="headerlink" title="重绘(Repaints):"></a>重绘(Repaints):</h2><h3 id="概念：-1"><a href="#概念：-1" class="headerlink" title="概念："></a>概念：</h3><p>当一个元素的外观发生改变，但没有改变布局,重新把元素外观绘制出来的过程，叫做重绘。</p><h3 id="常见的引起重绘的属性："><a href="#常见的引起重绘的属性：" class="headerlink" title="常见的引起重绘的属性："></a>常见的引起重绘的属性：</h3><table><thead><tr><th>属性：</th><th align="center">–</th><th align="right">–</th><th align="right">–</th></tr></thead><tbody><tr><td>color</td><td align="center">border-style</td><td align="right">visibility</td><td align="right">background</td></tr><tr><td>text-decoration</td><td align="center">background-image</td><td align="right">background-position</td><td align="right">background-repeat</td></tr><tr><td>outline-color</td><td align="center">outline</td><td align="right">outline-style</td><td align="right">border-radius</td></tr><tr><td>outline-width</td><td align="center">box-shadow</td><td align="right">background-size</td><td align="right"></td></tr></tbody></table><h2 id="重排优化建议："><a href="#重排优化建议：" class="headerlink" title="重排优化建议："></a>重排优化建议：</h2><p>重排的代价是高昂的，会破坏用户体验，并且让UI展示非常迟缓。通过减少重排的负面影响来提高用户体验的最简单方式就是尽可能的减少重排次数，重排范围。下面是一些行之有效的建议，大家可以用来参考。</p><h3 id="减少重排范围"><a href="#减少重排范围" class="headerlink" title="减少重排范围"></a>减少重排范围</h3><p>我们应该尽量以局部布局的形式组织html结构，尽可能小的影响重排的范围。</p><ul><li><p>尽可能在低层级的DOM节点上，而不是像上述全局范围的示例代码一样，如果你要改变p的样式，class就不要加在div上，通过父元素去影响子元素不好。</p></li><li><p>不要使用 table 布局，可能很小的一个小改动会造成整个 table 的重新布局。那么在不得已使用table的场合，可以设置table-layout:auto;或者是table-layout:fixed这样可以让table一行一行的渲染，这种做法也是为了限制reflow的影响范围。</p></li></ul><h3 id="减少重排次数"><a href="#减少重排次数" class="headerlink" title="减少重排次数"></a>减少重排次数</h3><h4 id="1-样式集中改变"><a href="#1-样式集中改变" class="headerlink" title="1.样式集中改变"></a>1.样式集中改变</h4><p>不要频繁的操作样式，对于一个静态页面来说，明智且可维护的做法是更改类名而不是修改样式，对于动态改变的样式来说，相较每次微小修改都直接触及元素，更好的办法是统一在 <code>cssText</code> 变量中编辑。虽然现在大部分现代浏览器都会有 <code>Flush</code> 队列进行渲染队列优化，但是有些老版本的浏览器比如IE6的效率依然低下。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="keyword">var</span> left = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">var</span> top = <span class="number">10</span>;</span><br><span class="line">el.style.left = left + <span class="string">"px"</span>;</span><br><span class="line">el.style.top = top + <span class="string">"px"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当top和left的值是动态计算而成时...</span></span><br><span class="line"><span class="comment">// better </span></span><br><span class="line">el.style.cssText += <span class="string">"; left: "</span> + left + <span class="string">"px; top: "</span> + top + <span class="string">"px;"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// better</span></span><br><span class="line">el.className += <span class="string">" className"</span>;</span><br></pre></td></tr></table></figure><h4 id="2-分离读写操作"><a href="#2-分离读写操作" class="headerlink" title="2.分离读写操作"></a>2.分离读写操作</h4><p>DOM 的多个读操作（或多个写操作），应该放在一起。不要两个读操作之间，加入一个写操作。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bad 强制刷新 触发四次重排+重绘</span></span><br><span class="line">div.style.left = div.offsetLeft + <span class="number">1</span> + <span class="string">'px'</span>;</span><br><span class="line">div.style.top = div.offsetTop + <span class="number">1</span> + <span class="string">'px'</span>;</span><br><span class="line">div.style.right = div.offsetRight + <span class="number">1</span> + <span class="string">'px'</span>;</span><br><span class="line">div.style.bottom = div.offsetBottom + <span class="number">1</span> + <span class="string">'px'</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// good 缓存布局信息 相当于读写分离 触发一次重排+重绘</span></span><br><span class="line"><span class="keyword">var</span> curLeft = div.offsetLeft;</span><br><span class="line"><span class="keyword">var</span> curTop = div.offsetTop;</span><br><span class="line"><span class="keyword">var</span> curRight = div.offsetRight;</span><br><span class="line"><span class="keyword">var</span> curBottom = div.offsetBottom;</span><br><span class="line"></span><br><span class="line">div.style.left = curLeft + <span class="number">1</span> + <span class="string">'px'</span>;</span><br><span class="line">div.style.top = curTop + <span class="number">1</span> + <span class="string">'px'</span>;</span><br><span class="line">div.style.right = curRight + <span class="number">1</span> + <span class="string">'px'</span>;</span><br><span class="line">div.style.bottom = curBottom + <span class="number">1</span> + <span class="string">'px'</span>;</span><br></pre></td></tr></table></figure><p>原来的操作会导致四次重排，读写分离之后实际上只触发了一次重排，这都得益于浏览器的渲染队列机制：</p><blockquote><p>当我们修改了元素的几何属性，导致浏览器触发重排或重绘时。它会把该操作放进渲染队列，等到队列中的操作到了一定的数量或者到了一定的时间间隔时，浏览器就会批量执行这些操作。</p></blockquote><h4 id="3-将-DOM-离线"><a href="#3-将-DOM-离线" class="headerlink" title="3.将 DOM 离线"></a>3.将 DOM 离线</h4><p>“离线”意味着不在当前的 DOM 树中做修改，我们可以这样做：</p><ul><li><p>使用 display:none</p><p>一旦我们给元素设置 <code>display:none</code> 时（只有一次重排重绘），元素便不会再存在在渲染树中，相当于将其从页面上“拿掉”，我们之后的操作将不会触发重排和重绘，添加足够多的变更后，通过 <code>display</code>属性显示（另一次重排重绘）。通过这种方式即使大量变更也只触发两次重排。另外，<code>visibility : hidden</code> 的元素只对重绘有影响，不影响重排。</p></li><li><p>通过 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/DocumentFragment" target="_blank" rel="external nofollow noopener noreferrer">documentFragment</a> 创建一个 <code>dom</code> 碎片,在它上面批量操作 <code>dom</code>，操作完成之后，再添加到文档中，这样只会触发一次重排。</p></li><li><p>复制节点，在副本上工作，然后替换它！</p></li></ul><h4 id="4-使用-absolute-或-fixed-脱离文档流"><a href="#4-使用-absolute-或-fixed-脱离文档流" class="headerlink" title="4.使用 absolute 或 fixed 脱离文档流"></a>4.使用 absolute 或 fixed 脱离文档流</h4><p>使用绝对定位会使的该元素单独成为渲染树中 <code>body</code> 的一个子元素，重排开销比较小，不会对其它节点造成太多影响。当你在这些节点上放置这个元素时，一些其它在这个区域内的节点可能需要重绘，但是不需要重排。</p><h4 id="5-优化动画"><a href="#5-优化动画" class="headerlink" title="5.优化动画"></a>5.优化动画</h4><ul><li><p>可以把动画效果应用到 <code>position</code>属性为 <code>absolute</code> 或 <code>fixed</code> 的元素上，这样对其他元素影响较小。</p><p>动画效果还应牺牲一些平滑，来换取速度，这中间的度自己衡量：<br>比如实现一个动画，以1个像素为单位移动这样最平滑，但是Layout就会过于频繁，大量消耗CPU资源，如果以3个像素为单位移动则会好很多</p></li><li><p>启用GPU加速<br><code>GPU</code> 硬件加速是指应用 <code>GPU</code> 的图形性能对浏览器中的一些图形操作交给 <code>GPU</code> 来完成，因为 <code>GPU</code> 是专门为处理图形而设计，所以它在速度和能耗上更有效率。</p><p><code>GPU</code> 加速通常包括以下几个部分：Canvas2D，布局合成, CSS3转换（transitions），CSS3 3D变换（transforms），WebGL和视频(video)。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 根据上面的结论</span></span><br><span class="line"><span class="comment">* 将 2d transform 换成 3d</span></span><br><span class="line"><span class="comment">* 就可以强制开启 GPU 加速</span></span><br><span class="line"><span class="comment">* 提高动画性能</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">div &#123;</span><br><span class="line">  transform: translate3d(<span class="number">10</span>px, <span class="number">10</span>px, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="如何在浏览器中查看页面渲染时间"><a href="#如何在浏览器中查看页面渲染时间" class="headerlink" title="如何在浏览器中查看页面渲染时间"></a>如何在浏览器中查看页面渲染时间</h2><p>1.打开开发者工具：点击 Performance 左侧有个小圆点 点击刷新页面会录制整个页面加载出来 时间的分配情况。如下图</p><p><img src="/uploads/i3_3.png" alt="image"></p><ul><li>蓝色: 网络通信和HTML解析</li><li>黄色: JavaScript执行</li><li>紫色: 样式计算和布局，即重排</li><li>绿色: 重绘</li></ul><p>哪种色块比较多，就说明性能耗费在那里。色块越长，问题越大。</p><p>2.点击 Event Log：单独勾选 Loading 项会显示 html 和 css 加载时间。如下图：</p><p><img src="/uploads/i3_4.png" alt="image"></p><p>3.解析完 DOM+CSSOM 之后会生成一个渲染树 Render Tree，就是 DOM 和 CSSOM 的一一对应关系。</p><p>4.通过渲染树中在屏幕上“画”出的所有节点，称为渲染。</p><h3 id="小结："><a href="#小结：" class="headerlink" title="小结："></a>小结：</h3><ul><li>渲染的三个阶段 Layout，Paint，Composite Layers。<br>Layout：重排，又叫回流。<br>Paint:重绘，重排重绘这些步骤都是在 CPU 中发生的。<br>Compostite Layers：CPU 把生成的 BitMap（位图）传输到 GPU，渲染到屏幕。 </li><li>CSS3 就是在 GPU 发生的：Transform  Opacity。在 GPU 发生的属性比较高效。所以 CSS3 性能比较高。</li></ul><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>非常感谢你看完了这篇很长的文章，也希望大家能重视重排的这些问题，在我们平时的开发中，也需要有意识的规避这些问题，才能让我们写出来的代码更规范！</p><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p><a href="https://segmentfault.com/a/1190000017491520" target="_blank" rel="external nofollow noopener noreferrer">掌握浏览器重绘(repaint)重排(reflow))-前端进阶</a><br><a href="https://csstriggers.com" target="_blank" rel="external nofollow noopener noreferrer">csstriggers</a><br><a href="https://efe.baidu.com/blog/hardware-accelerated-css-the-nice-vs-the-naughty/" target="_blank" rel="external nofollow noopener noreferrer">CSS硬件加速的好与坏</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/uploads/i3_1.jpg&quot; alt=&quot;image&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="前端" scheme="https://litgod.net/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="CSS" scheme="https://litgod.net/tags/CSS/"/>
    
      <category term="HTML" scheme="https://litgod.net/tags/HTML/"/>
    
  </entry>
  
  <entry>
    <title>浅谈 this、call、apply 和 bind</title>
    <link href="https://litgod.net/2020/01/19/%E5%85%B3%E4%BA%8E-this%E3%80%81call%E3%80%81apply-%E5%92%8C-bind-%E7%9A%84%E4%B8%80%E4%BA%9B%E7%90%86%E8%A7%A3/"/>
    <id>https://litgod.net/2020/01/19/%E5%85%B3%E4%BA%8E-this%E3%80%81call%E3%80%81apply-%E5%92%8C-bind-%E7%9A%84%E4%B8%80%E4%BA%9B%E7%90%86%E8%A7%A3/</id>
    <published>2020-01-19T06:41:18.000Z</published>
    <updated>2020-06-18T10:36:00.506Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/uploads/i2_1.jpg" alt="image"></p><a id="more"></a><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这是一个前端面试特别容易考的考点，很多初学者在这个问题上都容易踩坑，包括我也是经常性蒙圈。所以这次我决定将他们梳理下来，加深自己的理解。如果有出错的地方，欢迎指正。</p><h1 id="this-是什么"><a href="#this-是什么" class="headerlink" title="this 是什么"></a>this 是什么</h1><p>this 关键字是 Javascript ES5 中最复杂的机制之一。<a href="http://es6.ruanyifeng.com/#README" target="_blank" rel="external nofollow noopener noreferrer">ES6</a> 中新增的箭头函数，很大程度上避免了使用 this 所产生的错误。但是在 ES5 中，有时候我们会错误的判断了 this 的指向。其实 this 的指向，始终坚持一个原理：<strong>this 永远指向最后调用它的那个对象</strong>，记住了这句话，this 的指向你已经了解一半了。</p><h1 id="this-的四种绑定方式"><a href="#this-的四种绑定方式" class="headerlink" title="this 的四种绑定方式"></a>this 的四种绑定方式</h1><p>想要了解 this 的指向，我们首先要了解 this 的四种绑定方式：<strong>隐式绑定、显示绑定、new 绑定、window 绑定</strong>。</p><h2 id="隐式绑定"><a href="#隐式绑定" class="headerlink" title="隐式绑定"></a>隐式绑定</h2><p>执行绑定的第一个也是最常见的规则为 <strong>隐式绑定</strong>，它80% 的情况下它会告诉你 this 指向的对象是什么。</p><p>我们先来看一个简单的例子：<br>例1:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const user = &#123;</span><br><span class="line">  name: &apos;Cherry&apos;,</span><br><span class="line">  age: 27,</span><br><span class="line">  getName() &#123;</span><br><span class="line">    alert(`Hello, my name is $&#123;this.name&#125;`)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">user.getName()</span><br></pre></td></tr></table></figure><p>如果你要调用 <strong>user</strong> 对象上的  <strong>getName</strong> 方法，你会用到点<code>.</code></p><p>这就是所谓隐式绑定，<strong>函数被调用时先看一看点号左侧</strong>。如果有“点”就查看“点”左侧的对象，这个对象就是 <strong>this</strong> 的引用。</p><p>在上面的例子中，<strong>user</strong> 在“点号左侧”意味着 <strong>this</strong> 引用了 <strong>user</strong> 对象。所以就好像 在 <strong>getName</strong> 方法的内部 <strong>JavaScript</strong> 解释器把 <strong>this</strong> 变成了 <strong>user</strong>。</p><p>例2:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">const user = &#123;</span><br><span class="line">  name: &apos;Cherry&apos;,</span><br><span class="line">  age: 27,</span><br><span class="line">  getName() &#123;</span><br><span class="line">    alert(`Hello, my name is $&#123;this.name&#125;`)</span><br><span class="line">  &#125;,</span><br><span class="line">  mother: &#123;</span><br><span class="line">    name: &apos;Susan&apos;,</span><br><span class="line">    getName() &#123;</span><br><span class="line">      alert(`Hello, my name is $&#123;this.name&#125;`)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">user.getName()  // Cherry</span><br><span class="line">user.mother.getName()    // Susan</span><br></pre></td></tr></table></figure><p>如前所述，大约有 80% 的情况下在“点”的左侧都会有一个对象。这就是为什么在判断 this 指向时“查看点的左侧”是你要做的第一件事。但是，如果没有点呢？这就为我们引出了下一条规则：</p><h2 id="显示绑定"><a href="#显示绑定" class="headerlink" title="显示绑定"></a>显示绑定</h2><p>例3:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function getName () &#123;</span><br><span class="line">  alert(`Hello, my name is $&#123;this.name&#125;`)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const user = &#123;</span><br><span class="line">  name: &apos;Tyler&apos;,</span><br><span class="line">  age: 27,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在引出了一个问题，我们怎样能让 <strong>getName</strong> 方法调用的时候将 <strong>this</strong> 指向 <strong>user</strong> 对象？我们不能再像之前那样简单的使用 <strong>user.getName()</strong>，因为 <strong>user</strong> 并没有 <strong>getName</strong> 方法。在 <strong>JavaScript</strong> 中，每个函数都包含了一个能让你恰好解决这个问题的方法，这个方法的名字叫做 <strong>call、apply、bind</strong>。</p><p>用下面的代码可以在调用 <strong>getName</strong> 时用 <strong>user</strong> 做上下文。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getName.call(user)</span><br></pre></td></tr></table></figure><p>这就是第 2 条规则的基础（显示绑定），因为我们明确地（使用 .call）指定了 this 的引用。第六章节有对 call、apply、bind 详细的介绍，这里就不过多赘述了。</p><h2 id="new-绑定"><a href="#new-绑定" class="headerlink" title="new 绑定"></a>new 绑定</h2><p>第三条判断 <strong>this</strong> 引用的规则是 <strong>new</strong> 绑定。每当用 <strong>new</strong> 调用函数时，<strong>JavaScript</strong> 解释器都会在底层创建一个全新的对象并把这个对象当做 <strong>this</strong>。</p><blockquote><p>这看起来就像创建了新的函数，但实际上 <strong>JavaScript</strong> 函数是重新创建的对象。</p></blockquote><p>例4:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function User (name, age) &#123;</span><br><span class="line">  /*</span><br><span class="line">    JavaScript 会在底层创建一个新对象 `this`，它会代理不在 User 原型链上的属性。</span><br><span class="line">    如果一个函数用 new 关键字调用，this 就会指向解释器创建的新对象。</span><br><span class="line">  */</span><br><span class="line"></span><br><span class="line">  this.name = name</span><br><span class="line">  this.age = age</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const me = new User(&apos;Cherry&apos;, 27)</span><br></pre></td></tr></table></figure><p>这就有要说另一个面试经典问题了：new 的过程。<br>这里就简单的来看一下 new 的过程吧：<br>伪代码表示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var a = new User(&quot;Qi&quot;,&quot;Cherry&quot;);</span><br><span class="line"></span><br><span class="line">new User&#123;</span><br><span class="line">  var object = &#123;&#125;;</span><br><span class="line">  object.__proto__ = User.prototype;</span><br><span class="line">  var result = User.call(object,&quot;Li&quot;,&quot;Cherry&quot;);</span><br><span class="line">  return typeof result === &apos;object&apos;? result : object;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>new</strong> 的过程：<br>1.创建一个空对象 object;<br>2.将新创建的空对象的隐式原型指向其构造函数的显示原型；<br>3.使用 call 改变 this 的指向；<br>4.如果无返回值或者返回一个非对象值，则将 object 返回作为新对象；如果返回值是一个新对象的话那么直接直接返回该对象。</p><p>所以我们可以看到，在 new 的过程中，我们是使用 call 改变了 this 的指向。</p><h2 id="window-绑定"><a href="#window-绑定" class="headerlink" title="window 绑定"></a>window 绑定</h2><p>我们先来看下面这个例子：<br>例5:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function getAge () &#123;</span><br><span class="line">  console.log(`My age is $&#123;this.age&#125;`)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const user = &#123;</span><br><span class="line">  name: &apos;Cherry&apos;,</span><br><span class="line">  age: 27,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相信大家都知道为什么打印出来的是 <strong>My name is undefined</strong>，因为正如前面所说的，如果你想用 <strong>user</strong> 做上下文调用 <strong>getAge</strong>，你可以使用 <strong>.call</strong>、<strong>.apply</strong> 或 <strong>.bind</strong>。但如果我们没有用这些方法，而是直接和平时一样直接调用，<strong>JavaScript</strong> 会默认 <strong>this</strong> 指向 <strong>window</strong> 对象。但是 <strong>window</strong> 对象中并没有 <strong>name</strong> 属性，所以会打印 <strong>“My age is undefined“</strong>。</p><p>如果我们改成：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">age = 27</span><br><span class="line"></span><br><span class="line">function getAge () &#123;</span><br><span class="line">  console.log(`My age is $&#123;this.age&#125;`)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const user = &#123;</span><br><span class="line">  name: &apos;Cherry&apos;,</span><br><span class="line">  // age: 27,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这就是第 4 条规则为什么是 <strong>window</strong> 绑定 的原因。如果其它规则都没满足，<strong>JavaScript</strong> 就会默认 <strong>this</strong> 指向 <strong>window</strong> 对象。</p><blockquote><p>在 ES5 添加的 严格模式 中，JavaScript 不会默认 this 指向 window 对象，而会正确地把 this 保持为 undefined。</p></blockquote><p>例6:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&apos;use strict&apos;</span><br><span class="line"></span><br><span class="line">age = 27</span><br><span class="line"></span><br><span class="line">function sayAge () &#123;</span><br><span class="line">  console.log(`My age is $&#123;this.age&#125;`)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sayAge() // TypeError: Cannot read property &apos;age&apos; of undefined</span><br></pre></td></tr></table></figure><h1 id="this-的指向"><a href="#this-的指向" class="headerlink" title="this 的指向"></a>this 的指向</h1><p>前面讲了关于 this 的四种绑定方式，我们对于 this 的指向应该也有了一些自己的理解，还记得我们之前说的吗？<strong>this 永远指向最后调用它的那个对象，this 永远指向最后调用它的那个对象，this 永远指向最后调用它的那个对象。</strong>重要的事情说三遍。所以我们记好这句话看下面的例子：</p><p>例7:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var name = &quot;window&quot;;</span><br><span class="line">function fn() &#123;</span><br><span class="line">  var name = &quot;Cherry&quot;;</span><br><span class="line"></span><br><span class="line">  console.log(this.name);          // window</span><br><span class="line"></span><br><span class="line">  console.log(&quot;inner:&quot; + this);    // inner: Window</span><br><span class="line">&#125;</span><br><span class="line">fn();</span><br><span class="line">console.log(&quot;outer:&quot; + this)         // outer: Window</span><br></pre></td></tr></table></figure><p>我们看最后调用 <strong>fn</strong> 的地方 <code>fn();</code>，前面没有“点”，<strong>Javascript</strong> 调用的对象默认指向了全局对象 <strong>window</strong>，这就相当于是 <code>window.fn()；</code>所以根据刚刚的那句话“<strong>this 永远指向最后调用它的那个对象</strong>”，<strong>this</strong> 指向的就是 <strong>window</strong>。</p><blockquote><p>注意，这里我们没有使用严格模式，如果使用严格模式的话，全局对象就是 undefined，那么就会报错 Uncaught TypeError: Cannot read property ‘name’ of undefined。</p></blockquote><p>例8:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var name = &quot;window&quot;;</span><br><span class="line">var user = &#123;</span><br><span class="line">  name: &quot;Cherry&quot;,</span><br><span class="line">  fn: function () &#123;</span><br><span class="line">      console.log(this.name);      // Cherry</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">user.fn();</span><br></pre></td></tr></table></figure><p>根据上文所说，我们看到函数 <strong>fn</strong> 左侧有“点”，“点”的左侧是 <strong>user</strong>，所以 <strong>fn</strong> 是对象 <strong>user</strong> 调用的。所以打印的值就是 <strong>user</strong> 中的 <strong>name</strong> 的值。绑定规则是隐式绑定，是不是有一点清晰了呢~</p><p>我们再看下面这个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">var name = &quot;window&quot;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">function fnA()&#123;</span><br><span class="line">  var name = &quot;Cherry&quot;;</span><br><span class="line"></span><br><span class="line">  function fnB()&#123;</span><br><span class="line">    console.log(this.name);    // window </span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  //在A函数内部调用B函数</span><br><span class="line">  fnB();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//调用A函数</span><br><span class="line">fnA();</span><br></pre></td></tr></table></figure><p>在函数执行环境中使用 this 时,如果函数没有明显的作为非 window 对象的属性，而只是定义了函数，不管这个函数是不是定义在另一个函数中，这个函数中的 this 仍然表示 window 对象。</p><p>例9:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var name = &quot;window&quot;;</span><br><span class="line">var user = &#123;</span><br><span class="line">  name: &quot;Cherry&quot;,</span><br><span class="line">  fn: function () &#123;</span><br><span class="line">    console.log(this.name);      // Cherry</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">window.user.fn();</span><br></pre></td></tr></table></figure><p>这里打印 Cherry 的原因也是因为刚刚那句话“this 永远指向最后调用它的那个对象”，最后调用它的对象仍然是对象 user。</p><p>我们改动一下：</p><p>例10:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var name = &quot;window&quot;;</span><br><span class="line">var user = &#123;</span><br><span class="line">  // name: &quot;Cherry&quot;,</span><br><span class="line">  fn: function () &#123;</span><br><span class="line">    console.log(this.name);      // undefined</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">window.user.fn();</span><br></pre></td></tr></table></figure><p>这是因为调用 <strong>fn</strong> 的是 <strong>user</strong> 对象，也就是说 <strong>fn</strong> 的内部的 <strong>this</strong> 是对象 <strong>user</strong>，而对象 <strong>user</strong> 中并没有对 <strong>name</strong> 进行定义，所以 <strong>log</strong> 的 <strong>this.name</strong> 的值是 <strong>undefined</strong>。</p><p>这个例子还是说明了：<strong>this 永远指向最后调用它的那个对象</strong>，因为最后调用 <strong>fn</strong> 的对象是 <strong>user</strong>，所以就算 <strong>user</strong> 中没有 <strong>name</strong> 这个属性，也不会继续向上一个对象寻找 <strong>this.name</strong>，而是直接输出 <strong>undefined</strong>。</p><p>我们再来看一个比较坑的例子：<br>例11:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var name = &quot;window&quot;;</span><br><span class="line">var user = &#123;</span><br><span class="line">  name : null,</span><br><span class="line">  // name: &quot;Cherry&quot;,</span><br><span class="line">  fn : function () &#123;</span><br><span class="line">    console.log(this.name);      // window</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var f = user.fn;</span><br><span class="line">f();</span><br></pre></td></tr></table></figure><p>这里你可能会有疑问，为什么不是 Cherry？因为这里虽然将 <strong>user</strong> 对象的 <code>fn</code> 方法赋值给变量 <code>f</code> 了，但是<strong>没有调用</strong>，再接着跟我念这一句话：“<strong>this 永远指向最后调用它的那个对象</strong>”，由于刚刚的 <code>f</code> 并没有调用，所以 <code>fn()</code> 最后仍然是被 <strong>window</strong> 调用的。所以 <strong>this</strong> 指向的也就是 <strong>window</strong>。</p><p>由以上五个例子我们可以看出，this 的指向并不是在创建的时候就可以确定的，在 es5 中，<strong>this永远指向最后调用它的那个对象。</strong></p><h1 id="如何改变-this-的指向"><a href="#如何改变-this-的指向" class="headerlink" title="如何改变 this 的指向"></a>如何改变 this 的指向</h1><p>改变 this 的指向我总结有以下几种方法：</p><ul><li>使用 ES6 的箭头函数</li><li>在函数内部使用 _this = this</li><li>使用 apply、call、bind</li><li>new 实例化一个对象</li></ul><p>例12:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">var name = &quot;window&quot;;</span><br><span class="line"></span><br><span class="line">var user = &#123;</span><br><span class="line">  name : &quot;Cherry&quot;,</span><br><span class="line"></span><br><span class="line">  func1: function() &#123;</span><br><span class="line">    console.log(this.name)     </span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  func2: function() &#123;</span><br><span class="line">    setTimeout(function () &#123;</span><br><span class="line">      this.func1()</span><br><span class="line">    &#125;,100);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">user.func2()     // this.func1 is not a function</span><br></pre></td></tr></table></figure><p>我们逐一细说一下这个例子：<code>func2()</code>是被 <strong>user</strong>调用的，所以<code>func2</code>中的 <strong>this</strong> 应该指向 <strong>user</strong>。但是<code>func2</code>中又调用了 <strong>window</strong> 中的 <strong>setTimeout</strong> 方法。所以在 <strong>setTimeout</strong> 方法中的 <strong>this</strong> 指向的是后调用它的对象 <strong>window</strong>。但是在 <strong>window</strong> 中并没有 <strong>func1</strong> 函数。所以抛出错误：this.func1 is not a function。</p><p>如果我们想正确的调用 <strong>user</strong> 中的 <code>func1()</code>，应该怎么做呢？我们把这个例子作为 demo 进行改造。</p><h2 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h2><p>众所周知，ES6 的箭头函数是可以避免 ES5 中使用 this 的坑的。箭头函数的 this 始终指向函数定义时的 this，而非执行时。箭头函数需要记着这句话：“<strong>箭头函数中没有 this 绑定，必须通过查找作用域链来决定其值，如果箭头函数被非箭头函数包含，则 this 绑定的是最近一层非箭头函数的 this，否则，this 为 undefined</strong>”。</p><p>例13:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">var name = &quot;window&quot;;</span><br><span class="line"></span><br><span class="line">var user = &#123;</span><br><span class="line">  name : &quot;Cherry&quot;,</span><br><span class="line"></span><br><span class="line">  func1: function () &#123;</span><br><span class="line">    console.log(this.name)     </span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  func2: function () &#123;</span><br><span class="line">    setTimeout( () =&gt; &#123;</span><br><span class="line">        this.func1()</span><br><span class="line">    &#125;,100);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">user.func2()     // Cherry</span><br></pre></td></tr></table></figure><h2 id="在函数内部使用-this-this"><a href="#在函数内部使用-this-this" class="headerlink" title="在函数内部使用 _this = this"></a>在函数内部使用 _this = this</h2><p>如果不使用 ES6，那么这种方式应该是最简单的不会出错的方式了，我们是先将调用这个函数的对象保存在变量 _this 中，然后在函数中都使用这个 _this，这样 _this 就不会改变了。</p><p>例14:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">var name = &quot;window&quot;;</span><br><span class="line"></span><br><span class="line">var user = &#123;</span><br><span class="line"></span><br><span class="line">  name : &quot;Cherry&quot;,</span><br><span class="line"></span><br><span class="line">  func1: function () &#123;</span><br><span class="line">    console.log(this.name)     </span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  func2: function () &#123;</span><br><span class="line">    var _this = this;</span><br><span class="line">    setTimeout( function() &#123;</span><br><span class="line">      _this.func1()</span><br><span class="line">    &#125;,100);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">user.func2()       // Cherry</span><br></pre></td></tr></table></figure><p>这个例子中，在 func2 中，首先设置 var _this = this;，这里的 <strong>this</strong> 是调用 <code>func2</code> 的对象 <strong>user</strong>，为了防止在 <code>func2</code> 中的 <strong>setTimeout</strong> 被 <strong>window</strong> 调用而导致的在 <strong>setTimeout</strong> 中的 <strong>this</strong> 为 <strong>window</strong>。我们将 <strong>this</strong>(指向变量 user) 赋值给一个变量 <strong>_this</strong>，这样，在 <code>func2</code> 中我们使用 <strong>_this</strong> 就是指向对象 <strong>user</strong> 了。</p><h2 id="使用-apply、call、bind"><a href="#使用-apply、call、bind" class="headerlink" title="使用 apply、call、bind"></a>使用 apply、call、bind</h2><p>使用 apply、call、bind 函数也是可以改变 this 的指向的，原理稍后再讲，我们先来看一下是怎么实现的：</p><h3 id="使用-apply"><a href="#使用-apply" class="headerlink" title="使用 apply()"></a>使用 apply()</h3><p>例15:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">var user = &#123;</span><br><span class="line">  name: &quot;Cherry&quot;,</span><br><span class="line"></span><br><span class="line">  func1: function() &#123;</span><br><span class="line">    console.log(this.name)</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  func2: function() &#123;</span><br><span class="line">    setTimeout(function () &#123;</span><br><span class="line">      this.func1()</span><br><span class="line">    &#125;.apply(user), 100);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">user.func2()            // Cherry</span><br></pre></td></tr></table></figure><h3 id="使用-call"><a href="#使用-call" class="headerlink" title="使用 call()"></a>使用 call()</h3><p>例16:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">var user = &#123;</span><br><span class="line">  name: &quot;Cherry&quot;,</span><br><span class="line"></span><br><span class="line">  func1: function() &#123;</span><br><span class="line">    console.log(this.name)</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  func2: function() &#123;</span><br><span class="line">    setTimeout(function () &#123;</span><br><span class="line">      this.func1()</span><br><span class="line">    &#125;.call(user), 100);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">user.func2()            // Cherry</span><br></pre></td></tr></table></figure><h3 id="使用-bind"><a href="#使用-bind" class="headerlink" title="使用 bind()"></a>使用 bind()</h3><p>例17:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">var user = &#123;</span><br><span class="line">  name: &quot;Cherry&quot;,</span><br><span class="line"></span><br><span class="line">  func1: function() &#123;</span><br><span class="line">    console.log(this.name)</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  func2: function() &#123;</span><br><span class="line">    setTimeout(function () &#123;</span><br><span class="line">      this.func1()</span><br><span class="line">    &#125;.bind(user)(), 100);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">user.func2()            // Cherry</span><br></pre></td></tr></table></figure><h1 id="apply、call、bind-的区别"><a href="#apply、call、bind-的区别" class="headerlink" title="apply、call、bind 的区别"></a>apply、call、bind 的区别</h1><p>刚刚我们已经介绍了 apply、call、bind 都是可以改变 this 的指向的，但是这三个函数稍有不同。</p><p>在 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/apply" target="_blank" rel="external nofollow noopener noreferrer">MDN</a> 中定义 apply 如下；</p><blockquote><p>apply() 方法调用一个函数, 其具有一个指定的this值，以及作为一个数组（或类似数组的对象）提供的参数</p></blockquote><p>语法：</p><blockquote><p>fun.apply(thisArg, [argsArray])</p></blockquote><ul><li>thisArg：在 fun 函数运行时指定的 this 值。需要注意的是，指定的 this 值并不一定是该函数执行时真正的 this 值，如果这个函数处于非严格模式下，则指定为 null 或 undefined 时会自动指向全局对象（浏览器中就是window对象），同时值为原始值（数字，字符串，布尔值）的 this 会指向该原始值的自动包装对象。</li><li>argsArray：一个数组或者类数组对象，其中的数组元素将作为单独的参数传给 fun 函数。如果该参数的值为null 或 undefined，则表示不需要传入任何参数。从ECMAScript 5 开始可以使用类数组对象。浏览器兼容性请参阅本文底部内容。</li></ul><h2 id="apply-和-call-的区别"><a href="#apply-和-call-的区别" class="headerlink" title="apply 和 call 的区别"></a>apply 和 call 的区别</h2><p>其实 apply 和 call 基本类似，他们的区别只是传入的参数不同。</p><p>call 的语法为: </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fun.call(thisArg[, arg1[, arg2[, ...]]])</span><br></pre></td></tr></table></figure><p>所以 apply 和 call 的区别是 call 方法接受的是若干个参数列表，而 apply 接收的是一个包含多个参数的数组。</p><p>例18:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var user =&#123;</span><br><span class="line">  name: &quot;Cherry&quot;,</span><br><span class="line">  fn: function(a,b) &#123;</span><br><span class="line">    console.log(a + b)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var newUser = user.fn;</span><br><span class="line">newUser.apply(user,[1,2])     // 3</span><br></pre></td></tr></table></figure><p>例19:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var user =&#123;</span><br><span class="line">  name: &quot;Cherry&quot;,</span><br><span class="line">  fn: function(a,b) &#123;</span><br><span class="line">    console.log(a + b)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var newUser =user.fn;</span><br><span class="line">newUser.call(user, 1, 2)       // 3</span><br></pre></td></tr></table></figure><h2 id="bind-和-apply、call-区别"><a href="#bind-和-apply、call-区别" class="headerlink" title="bind 和 apply、call 区别"></a>bind 和 apply、call 区别</h2><p>我们先来将刚刚的例子使用 bind 试一下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var user =&#123;</span><br><span class="line">  name: &quot;Cherry&quot;,</span><br><span class="line">  fn: function(a,b) &#123;</span><br><span class="line">    console.log(a + b)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var newUser = user.fn;</span><br><span class="line">nreUser.bind(user,1,2)</span><br></pre></td></tr></table></figure><p>我们会发现并没有输出，这是为什么呢，我们来看一下 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/bind" target="_blank" rel="external nofollow noopener noreferrer">MDN</a> 上的文档说明：</p><blockquote><p>bind()方法创建一个新的函数, 当被调用时，将其this关键字设置为提供的值，在调用新函数时，在任何提供之前提供一个给定的参数序列。</p></blockquote><p>所以我们可以看出，bind 是创建一个新的函数，我们必须要手动去调用:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var user =&#123;</span><br><span class="line">  name: &quot;Cherry&quot;,</span><br><span class="line">  fn: function (a,b) &#123;</span><br><span class="line">    console.log( a + b)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var newUser = user.fn;</span><br><span class="line">newUser.bind(user,1,2)()           // 3</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>每当在函数内部看到 this 关键字时，我们可以用以下步骤判断 this 的指向。</p><p>1.查看函数在哪被调用。<br>2.点左侧有没有对象？如果有，它就是 “this” 的引用。如果没有，继续第 3 步。<br>3.该函数是不是用 “call”、“apply” 或者 “bind” 调用的？如果是，它会显式地指明 “this” 的引用。如果不是，继续第 4 步。<br>4.该函数是不是用 “new” 调用的？如果是，“this” 指向的就是 JavaScript 解释器新创建的对象。如果不是，继续第 5 步。<br>5.是否在“严格模式”下？如果是，“this” 就是 undefined，如果不是，继续第 6 步。<br>6.JavaScript 很奇怪，“this” 会指向 “window” 对象。</p><p>另外切记：this<strong>永远</strong>指向最后调用它的那个对象。this永远指向<strong>最后调用</strong>它的那个对象。this永远指向最后调用它的<strong>那个对象</strong>。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/uploads/i2_1.jpg&quot; alt=&quot;image&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="前端" scheme="https://litgod.net/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>超详细的Github+Hexo搭建教程</title>
    <link href="https://litgod.net/2019/10/31/%E8%B6%85%E8%AF%A6%E7%BB%86%E7%9A%84Github-Hexo%E6%90%AD%E5%BB%BA%E6%95%99%E7%A8%8B/"/>
    <id>https://litgod.net/2019/10/31/%E8%B6%85%E8%AF%A6%E7%BB%86%E7%9A%84Github-Hexo%E6%90%AD%E5%BB%BA%E6%95%99%E7%A8%8B/</id>
    <published>2019-10-31T12:45:02.000Z</published>
    <updated>2020-03-10T02:26:54.819Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/uploads/hexo.jpg" alt="image"></p><a id="more"></a><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>不管你是程序猿（媛），产品经理，设计师，运维工程师…还是从事其他职业，应该都想拥有一个属于自己的个人博客网站吧。如果你是，那么请跟随目录，搭建属于你的个人博客吧!一起来技术分享，记录生活…</p><h2 id="Hexo-是什么"><a href="#Hexo-是什么" class="headerlink" title="Hexo 是什么"></a>Hexo 是什么</h2><p><a href="https://hexo.io" target="_blank" rel="external nofollow noopener noreferrer">Hexo</a> 是一个基于 <a href="https://nodejs.org/en" target="_blank" rel="external nofollow noopener noreferrer">Node.js</a>的快速，简单月功能强大的博客框架。可以使用简单的命令生成静态网页，并托管到 Github 上。<br>#TODO</p><h2 id="来搭建属于你的个人博客吧～"><a href="#来搭建属于你的个人博客吧～" class="headerlink" title="来搭建属于你的个人博客吧～"></a>来搭建属于你的个人博客吧～</h2><h3 id="Gihub-创建个人仓库"><a href="#Gihub-创建个人仓库" class="headerlink" title="Gihub 创建个人仓库"></a>Gihub 创建个人仓库</h3><ul><li><p>首先先登录到 <a href="https://github.com" target="_blank" rel="external nofollow noopener noreferrer">Github</a>。如果没有个人账号，先进行注册，注册完成后，点击登录进入 Github。</p></li><li><p>点击绿色的 <strong>New</strong> 按钮新建一个仓库，将仓库名称命为： 用户名.github.io，例如：qiruohan.github.io，这个写法是固定的。<br><img src="/uploads/i_1.jpg" alt="image"><br><img src="/uploads/i_2.jpg" alt="image"></p></li><li><p>注意：仓库名称要和你的用户名保持一致，后缀.github.io 的作用是 Github 识别到.github.io 后缀就会为你自动开启<a href="https://pages.github.com/" target="_blank" rel="external nofollow noopener noreferrer">Github Page</a>，作为你个人博客的仓库。</p></li></ul><p>然后项目就建成了，点击Settings，向下拉到最后有个GitHub Pages，点击Choose a theme可以选择一个主题。然后点击那个链接，就会出现自己的网页啦～</p><h3 id="安装-Node-js"><a href="#安装-Node-js" class="headerlink" title="安装 Node.js"></a>安装 Node.js</h3><p>Node.js 是基于 <a href="https://v8.dev/" target="_blank" rel="external nofollow noopener noreferrer">Chrome V8 JavaScript 引擎</a> 构建的语言，是一项服务器端技术。<br>下载地址：<a href="https://nodejs.org/en/download/" target="_blank" rel="external nofollow noopener noreferrer">Node.js | Download</a>，下载当前操作系统的安装包，安装选项全部默认。注意下载的安装包中已经包含了环境变量以及 <a href="https://www.npmjs.com/" target="_blank" rel="external nofollow noopener noreferrer">npm</a>，所以安装完安装包后无需另外再下载 npm。</p><p>检测 Node.js 是否安装成功，在命令行中输入：<strong>node -v</strong><br><img src="/uploads/i_3.png" alt="image"></p><p>检测 npm 是否安装成功，在命令行中输入：<strong>npm -v</strong><br><img src="/uploads/i_4.png" alt="image"></p><p>显示版本号，那么就说明 node.js 安装成功了。</p><h3 id="安装-Git"><a href="#安装-Git" class="headerlink" title="安装 Git"></a>安装 Git</h3><p><a href="https://git-scm.com/" target="_blank" rel="external nofollow noopener noreferrer">Git</a> 是一个开源的分布式版本控制系统，旨在快速高效地处理从小型到大型项目的所有内容。具有便捷的创建本地分支，创建暂存区域，处理多个工作流等功能。简单来说，使用 Git 可以把本地文件同步到 Github 上，完成多人多空间的便捷式管理。</p><p><strong>Windows 下</strong>安装下载地址：<a href="https://git-scm.com/download/" target="_blank" rel="external nofollow noopener noreferrer">Git | Downloads</a>，安装选项还是全部默认，安装完成后在命令行中输入 <strong>git –version</strong> 验证是否安装成功。<br><img src="/uploads/i_5.png" alt="image"><br>显示版本号，那么就说明 git 安装成功了。安装成功后，将你的Git与GitHub帐号绑定，鼠标右击打开Git Bash，设置user.name和user.email配置信息。<br>之后移步到 mac 下安装流程的<strong>第三步：设置github的 username 和 email</strong>，做接来下的操作。</p><p><strong>Mac 下安装</strong>：</p><ul><li><p>如果未安 homebrew，需要先安装 homebrew</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;</span><br></pre></td></tr></table></figure></li><li><p>安装 git</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install git</span><br></pre></td></tr></table></figure></li><li><p>检查 git 是否安装成功</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git --version</span><br></pre></td></tr></table></figure></li><li><p>安装成功后，先设置github的 username 和 email（github 在每次提交的时候都会记录他们）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name &quot;你的GitHub用户名&quot;</span><br><span class="line">git config --global user.email &quot;你的GitHub注册邮箱&quot;</span><br></pre></td></tr></table></figure></li><li><p>使用终端命令创建 ssh key</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;你的GitHub注册邮箱&quot;</span><br></pre></td></tr></table></figure><p>然后直接三个回车即可，默认不需要设置密码<br>然后找到生成的.ssh的文件夹中的id_rsa.pub密钥，将内容全部复制</p></li><li><p>打开 <a href="https://github.com/settings/keys" target="_blank" rel="external nofollow noopener noreferrer">GitHub_Settings_keys</a> 页面，新建new SSH Key<br><img src="/uploads/i_10.png" alt="image"></p></li></ul><p>Title为标题，任意填即可，将刚刚复制的id_rsa.pub内容粘贴进去，最后点击Add SSH key。</p><ul><li>在终端检测GitHub公钥设置是否成功，输入 ssh <a href="mailto:git@github.com" target="_blank" rel="external nofollow noopener noreferrer">git@github.com</a>。<br><img src="/uploads/i_11.png" alt="image"></li></ul><p>如上则说明成功。</p><p>注意：这里之所以设置GitHub密钥原因是，通过非对称加密的公钥与私钥来完成加密，公钥放置在GitHub上，私钥放置在自己的电脑里。GitHub要求每次推送代码都是合法用户，所以每次推送都需要输入账号密码验证推送用户是否是合法用户，为了省去每次输入密码的步骤，采用了ssh，当你推送的时候，git就会匹配你的私钥跟GitHub上面的公钥是否是配对的，若是匹配就认为你是合法用户，则允许推送。这样可以保证每次的推送都是正确合法的。</p><h3 id="安装-Hexo"><a href="#安装-Hexo" class="headerlink" title="安装 Hexo"></a>安装 Hexo</h3><p>Hexo 就是我们搭建个人博客所使用的框架，我们需要在合适的地方先创建一个文件夹，用来存放自己的博客文件，例如我命名为blog2。</p><p>使用命令行进入到该目录下，输入 <code>npm i hexo-cli -g</code> 安装 Hexo，安装成功后，会显示安装所使用的总时长。<br><img src="/uploads/i_6.png" alt="image"></p><p>安装完成后，初始化我们的博客，输入 <code>hexo init blog</code>。<br>注意：这里的命令都作用在刚刚创建的 blog2 文件夹下。<br><img src="/uploads/i_7.png" alt="image"></p><p>初始化时间可能会比较长，耐心等待…<br><img src="/uploads/i_8.png" alt="image"></p><p>初始化完成后，会发现 blog2 下又新增了一个文件夹，名为 blog，与 <code>hexo init</code> 后面输入的文件名同名。我们进入新创建的文件夹 blog 下，输入以下三条命名来检测一下我们的网站雏形</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">hexo new test</span><br><span class="line"></span><br><span class="line">hexo g</span><br><span class="line"></span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure><p><img src="/uploads/i_9.png" alt="image"></p><p>到这里，我们的个人博客就搭建完成啦！并且已经写出了我们的第一篇文章～</p><h3 id="hexo-常用命令"><a href="#hexo-常用命令" class="headerlink" title="hexo 常用命令"></a>hexo 常用命令</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">1.安装 Hexo</span><br><span class="line">  npm install hexo -g</span><br><span class="line">2.升级 Hexo</span><br><span class="line">  npm update hexo -g</span><br><span class="line">3.初始化博客</span><br><span class="line">  hexo init &quot;博客站点&quot;</span><br><span class="line">4.新建文章</span><br><span class="line">  hexo n &quot;我的博客&quot;  或  hexo new &quot;我的博客&quot; </span><br><span class="line">5.生成博客</span><br><span class="line">  hexo g  或 hexo generate</span><br><span class="line">6.启动服务</span><br><span class="line">  hexo s  或  hexo server</span><br><span class="line">7.部署博客</span><br><span class="line">  hexo d  或  hexo deploy</span><br><span class="line">8.更改端口</span><br><span class="line">  hexo server -p 5000</span><br><span class="line">9.自定义 IP</span><br><span class="line">  hexo server -i 192.168.1.1</span><br><span class="line">10.清除缓存，若是网页正常情况下可以忽略这条命令</span><br><span class="line">  hexo clean</span><br><span class="line">11.新建页面</span><br><span class="line">  hexo new page xxx</span><br></pre></td></tr></table></figure><h3 id="推送博客站点"><a href="#推送博客站点" class="headerlink" title="推送博客站点"></a>推送博客站点</h3><p>上图只是本地的预览，如果想让大家都看到你的博客，就得把项目放在公网上被大家访问。打开博客根目录下的_config.yml文件，这是博客的配置文件，在这里你可以修改与博客相关的各种信息。这个文件称之为<strong>站点配置文件</strong>。<br><img src="/uploads/i_12.png" alt="image"></p><p>修改最后一行的配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: https://github.com/qiruohan/qiruohan.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure><p>repository修改为你自己的github项目地址。</p><p>这里其实就是给 hexo d 命令做相应的配置，让 hexo 知道要把你的博客部署在哪个位置，我们需要把项目部署到我们自己的GitHub的仓库里。</p><p>安装Git部署插件，输入命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><p>这时，我们分别输入三条命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean </span><br><span class="line">hexo g </span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure><p>打开浏览器，在地址栏输入你的放置个人网站的仓库路径，即 xxxx.github.io, 比如我的：qiruohan.github.io， 你就会发现你的博客已经上线了，可以在网络上被访问了。</p><h3 id="更换主题"><a href="#更换主题" class="headerlink" title="更换主题"></a>更换主题</h3><p>如果你不喜欢 Hexo 的默认主题，可以更换主题，hexo主题有很多，你可以从网上找到很多很好看的主题，每个主题也都有自己的安装教程，你可以试着看一看。</p><p>我这里使用的主题是<a href="https://theme-next.iissnan.com/" target="_blank" rel="external nofollow noopener noreferrer">nexT</a>，所以我说一下我的安装配置吧～</p><ul><li><p>安装 nexT 主题，通过 git 命令将 nexT 克隆下来， 在博客站点目录下（我的是blog），使用 git clone 命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/theme-next/hexo-theme-next themes/next</span><br></pre></td></tr></table></figure></li><li><p>等待克隆完毕，找到 themes 文件夹下的 next 文件， 这就是我们刚刚克隆下来的主题了。<br><img src="/uploads/i_13.png" alt="image"></p></li><li><p>返回根目录，找到我们的站点文件_config.yml，打开并修改里面的 theme 配置以使我们刚刚克隆下来的主题生效。</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">theme: next</span><br></pre></td></tr></table></figure><p>修改theme: landscape为next，注意theme和next之间要有空格，否则无效。</p><p>正确设置好后，我们更换的主题就生效啦～每个主题都可以有自己个性化的配置，可以打开主题的_config.yml配置文件（注意不是站点配置文件），可以按照你的想法做一些个性化的配置，之后再次部署网站，hexo clean、hexo g、hexo d，查看效果。选择其他主题，按照上述过程即可实现。</p><h3 id="发布文章"><a href="#发布文章" class="headerlink" title="发布文章"></a>发布文章</h3><p>1.文章头设置</p><h3 id="MarkDown-语法"><a href="#MarkDown-语法" class="headerlink" title="MarkDown 语法"></a>MarkDown 语法</h3><p>Markdown是一种可以使用普通文本编辑器编写的标记语言，通过简单的标记语法，具体语法参看：<a href="https://www.appinn.com/markdown/" target="_blank" rel="external nofollow noopener noreferrer">Markdown 语法说明(简体中文版)</a> 可以说十分钟就可以入门，非常简单发方便。当然，选择一个好的Markdown编辑器也是非常重要的，mac版推荐使用 MacDown 或者直接使用 VsCode 编写 Markdown 文件， 非常方便。</p><h3 id="绑定域名"><a href="#绑定域名" class="headerlink" title="绑定域名"></a>绑定域名</h3><p>现在默认的域名还是xxx.github.io，而如果我们想使用个性化的域名，就需要绑定我们自己的域名，首先你需要购买一个域名，XX云都能买，国内主流的域名代理厂商也就阿里云和腾讯云。下面给大家演示阿里云的相关配置：</p><ul><li>登录阿里云，进入管理控制台的域名列表，找到你的个性化域名，进入解析</li></ul><p><img src="/uploads/i_14.png" alt="image"></p><ul><li>添加解析</li></ul><p><img src="/uploads/i_15.png" alt="image"></p><p>一共包括两条解析记录，记录类型都是CNAME，CNAME的记录值是：你的用户名.github.io，这里千万别弄错了。</p><ul><li>登录GitHub，进入之前创建的仓库，点击settings，设置Custom domain，输入你的域名，点击保存。<br><img src="/uploads/i_16.png" alt="image"></li></ul><p>注意：如果你把 Enforce HTTPS 钩上，github 会自动帮你升级为 https 的哦～</p><ul><li><p>这时候你的项目根目录应该会出现一个名为CNAME的文件了。如果没有的话，打开你本地博客/source目录，手动创建一个CNAME文件，注意没有后缀。写上你的域名。<br>注意，只要写进你自己的域名即可。如果带有www，那么以后访问的时候必须带有www完整的域名才可以访问，但如果不带有www，以后访问的时候带不带www都可以访问。所以建议，不要带有www。<br><img src="/uploads/i_17.png" alt="image"></p></li><li><p>点击保存。保存成功后运行hexo g、hexo d传到github上。这时候打开浏览器在地址栏输入你的个性化域名将会直接进入你自己搭建的网站。</p></li></ul><h3 id="个性化配置"><a href="#个性化配置" class="headerlink" title="个性化配置"></a>个性化配置</h3><h3 id="寻找图床"><a href="#寻找图床" class="headerlink" title="寻找图床"></a>寻找图床</h3>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/uploads/hexo.jpg&quot; alt=&quot;image&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="前端" scheme="https://litgod.net/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="Hexo" scheme="https://litgod.net/tags/Hexo/"/>
    
  </entry>
  
</feed>
