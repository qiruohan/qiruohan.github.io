<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Litgod&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://litgod.net/"/>
  <updated>2020-06-01T07:40:58.477Z</updated>
  <id>https://litgod.net/</id>
  
  <author>
    <name>齐小神</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Webpack的前世今生</title>
    <link href="https://litgod.net/2020/06/01/Webpack%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/"/>
    <id>https://litgod.net/2020/06/01/Webpack%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/</id>
    <published>2020-06-01T07:30:59.000Z</published>
    <updated>2020-06-01T07:40:58.477Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/uploads/i3_1.jpg" alt="image"></p><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/uploads/i3_1.jpg&quot; alt=&quot;image&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="前端" scheme="https://litgod.net/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="Webpack" scheme="https://litgod.net/tags/Webpack/"/>
    
  </entry>
  
  <entry>
    <title>重排(reflow)和重绘(repaint)</title>
    <link href="https://litgod.net/2020/01/30/%E9%87%8D%E7%BB%98%E5%92%8C%E9%87%8D%E6%8E%92/"/>
    <id>https://litgod.net/2020/01/30/%E9%87%8D%E7%BB%98%E5%92%8C%E9%87%8D%E6%8E%92/</id>
    <published>2020-01-30T14:48:22.000Z</published>
    <updated>2020-03-10T02:32:05.799Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/uploads/i3_1.jpg" alt="image"></p><a id="more"></a><p>之前面试的大佬问我关于重排重绘的原理和具体操作，一下子把我问蒙了。回家便默默地把问题记下来，仔细总结……在阅读了一些文章后，自己也有了一定的理解，所以分享给大家。希望大家也能耐心把这篇文章看完，认真思考，彻底掌握这个知识点！</p><h2 id="页面生成的过程："><a href="#页面生成的过程：" class="headerlink" title="页面生成的过程："></a>页面生成的过程：</h2><p>1.HTML 被 HTML 解析器解析成 DOM 树；<br>2.CSS  被 CSS 解析器解析成 CSSOM 树；<br>3.结合 DOM 树和 CSSOM 树，生成一棵渲染树(Render Tree)，这一过程称为 Attachment；<br>4.生成布局(flow)，浏览器在屏幕上“画”出渲染树中的所有节点；<br>5.将布局绘制(paint)在屏幕上，显示出整个页面。</p><p>第四步和第五步是最耗时的部分，这两步合起来，就是我们通常所说的渲染。</p><p><img src="/uploads/i3_2.png" alt="image"></p><h2 id="渲染："><a href="#渲染：" class="headerlink" title="渲染："></a>渲染：</h2><p>在页面的生命周期中，<strong>网页生成的时候，至少会渲染一次</strong>。<strong>在用户访问的过程中，还会不断触发重排(reflow)和重绘(repaint)</strong>，不管页面发生了重绘还是重排，都会影响性能，<strong>最可怕的是重排，会使我们付出高额的性能代价，所以我们应尽量避免</strong>。</p><h2 id="重排比重绘大："><a href="#重排比重绘大：" class="headerlink" title="重排比重绘大："></a>重排比重绘大：</h2><p>大，在这个语境里的意思是：谁能影响谁？</p><ul><li>重绘：某些元素的外观被改变，例如：元素的填充颜色</li><li>重排：重新生成布局，重新排列元素。</li></ul><p>就如上面的概念一样，单单改变元素的外观，肯定不会引起网页重新生成布局，但当浏览器完成重排之后，将会重新绘制受到此次重排影响的部分。比如改变元素高度，这个元素乃至周边dom都需要重新绘制。</p><p>也就是说：<strong>重绘不一定导致重排，但重排一定会导致重绘</strong>。</p><h2 id="重排-reflow-："><a href="#重排-reflow-：" class="headerlink" title="重排(reflow)："></a>重排(reflow)：</h2><h3 id="概念："><a href="#概念：" class="headerlink" title="概念："></a>概念：</h3><p>当DOM的变化影响了元素的几何信息(元素的的位置和尺寸大小)，浏览器需要重新计算元素的几何属性，将其安放在界面中的正确位置，这个过程叫做重排。</p><p>重排也叫回流，简单的说就是重新生成布局，重新排列元素。</p><h3 id="下面情况会发生重排："><a href="#下面情况会发生重排：" class="headerlink" title="下面情况会发生重排："></a>下面情况会发生重排：</h3><ul><li>页面初始渲染，这是开销最大的一次重排</li><li>添加/删除可见的DOM元素</li><li>改变元素位置</li><li>改变元素尺寸，比如边距、填充、边框、宽度和高度等</li><li>改变元素内容，比如文字数量，图片大小等</li><li>改变元素字体大小</li><li>改变浏览器窗口尺寸，比如resize事件发生时</li><li>激活CSS伪类（例如：<code>:hover</code>）</li><li>设置 style 属性的值，因为通过设置style属性改变结点样式的话，每一次设置都会触发一次reflow</li><li>查询某些属性或调用某些计算方法：offsetWidth、offsetHeight等，除此之外，当我们调用 <code>getComputedStyle</code>方法，或者IE里的 <code>currentStyle</code> 时，也会触发重排，原理是一样的，都为求一个“即时性”和“准确性”。</li></ul><table><thead><tr><th>常见引起重排属性和方法</th><th align="center">–</th><th align="right">–</th><th align="right">–</th></tr></thead><tbody><tr><td>width</td><td align="center">height</td><td align="right">margin</td><td align="right">padding</td></tr><tr><td>display</td><td align="center">border-width</td><td align="right">border</td><td align="right">position</td></tr><tr><td>overflow</td><td align="center">font-size</td><td align="right">vertical-align</td><td align="right">min-height</td></tr><tr><td>clientWidth</td><td align="center">clientHeight</td><td align="right">clientTop</td><td align="right">clientLeft</td></tr><tr><td>offsetWudth</td><td align="center">offsetHeight</td><td align="right">offsetTop</td><td align="right">offsetLeft</td></tr><tr><td>scrollWidth</td><td align="center">scrollHeight</td><td align="right">scrollTop</td><td align="right">scrollLeft</td></tr><tr><td>scrollIntoView()</td><td align="center">scrollTo()</td><td align="right">getComputedStyle()</td><td align="right"></td></tr><tr><td>getBoundingClientRect()</td><td align="center">scrollIntoViewIfNeeded()</td><td align="right"></td><td align="right"></td></tr></tbody></table><h3 id="重排影响的范围："><a href="#重排影响的范围：" class="headerlink" title="重排影响的范围："></a>重排影响的范围：</h3><p>由于浏览器渲染界面是基于流失布局模型的，所以触发重排时会对周围DOM重新排列，影响的范围有两种：</p><ul><li>全局范围：从根节点html开始对整个渲染树进行重新布局。</li><li>局部范围：对渲染树的某部分或某一个渲染对象进行重新布局</li></ul><p><strong>全局范围重排：</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"hello"</span>&gt;</span><br><span class="line">    &lt;h4&gt;hello&lt;<span class="regexp">/h4&gt;</span></span><br><span class="line"><span class="regexp">    &lt;p&gt;&lt;strong&gt;Name:&lt;/</span>strong&gt;BDing&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">    &lt;h5&gt;male&lt;/</span>h5&gt;</span><br><span class="line">    &lt;ol&gt;</span><br><span class="line">      &lt;li&gt;coding&lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">      &lt;li&gt;loving&lt;/</span>li&gt;</span><br><span class="line">    &lt;<span class="regexp">/ol&gt;</span></span><br><span class="line"><span class="regexp">  &lt;/</span>div&gt;</span><br><span class="line">&lt;<span class="regexp">/body&gt;</span></span><br></pre></td></tr></table></figure><p>当p节点上发生reflow时，hello和body也会重新渲染，甚至h5和ol都会收到影响。</p><p><strong>局部范围重排：</strong></p><p>用局部布局来解释这种现象：把一个dom的宽高之类的几何信息定死，然后在dom内部触发重排，就只会重新渲染该dom内部的元素，而不会影响到外界。</p><h2 id="重绘-Repaints"><a href="#重绘-Repaints" class="headerlink" title="重绘(Repaints):"></a>重绘(Repaints):</h2><h3 id="概念：-1"><a href="#概念：-1" class="headerlink" title="概念："></a>概念：</h3><p>当一个元素的外观发生改变，但没有改变布局,重新把元素外观绘制出来的过程，叫做重绘。</p><h3 id="常见的引起重绘的属性："><a href="#常见的引起重绘的属性：" class="headerlink" title="常见的引起重绘的属性："></a>常见的引起重绘的属性：</h3><table><thead><tr><th>属性：</th><th align="center">–</th><th align="right">–</th><th align="right">–</th></tr></thead><tbody><tr><td>color</td><td align="center">border-style</td><td align="right">visibility</td><td align="right">background</td></tr><tr><td>text-decoration</td><td align="center">background-image</td><td align="right">background-position</td><td align="right">background-repeat</td></tr><tr><td>outline-color</td><td align="center">outline</td><td align="right">outline-style</td><td align="right">border-radius</td></tr><tr><td>outline-width</td><td align="center">box-shadow</td><td align="right">background-size</td><td align="right"></td></tr></tbody></table><h2 id="重排优化建议："><a href="#重排优化建议：" class="headerlink" title="重排优化建议："></a>重排优化建议：</h2><p>重排的代价是高昂的，会破坏用户体验，并且让UI展示非常迟缓。通过减少重排的负面影响来提高用户体验的最简单方式就是尽可能的减少重排次数，重排范围。下面是一些行之有效的建议，大家可以用来参考。</p><h3 id="减少重排范围"><a href="#减少重排范围" class="headerlink" title="减少重排范围"></a>减少重排范围</h3><p>我们应该尽量以局部布局的形式组织html结构，尽可能小的影响重排的范围。</p><ul><li><p>尽可能在低层级的DOM节点上，而不是像上述全局范围的示例代码一样，如果你要改变p的样式，class就不要加在div上，通过父元素去影响子元素不好。</p></li><li><p>不要使用 table 布局，可能很小的一个小改动会造成整个 table 的重新布局。那么在不得已使用table的场合，可以设置table-layout:auto;或者是table-layout:fixed这样可以让table一行一行的渲染，这种做法也是为了限制reflow的影响范围。</p></li></ul><h3 id="减少重排次数"><a href="#减少重排次数" class="headerlink" title="减少重排次数"></a>减少重排次数</h3><h4 id="1-样式集中改变"><a href="#1-样式集中改变" class="headerlink" title="1.样式集中改变"></a>1.样式集中改变</h4><p>不要频繁的操作样式，对于一个静态页面来说，明智且可维护的做法是更改类名而不是修改样式，对于动态改变的样式来说，相较每次微小修改都直接触及元素，更好的办法是统一在 <code>cssText</code> 变量中编辑。虽然现在大部分现代浏览器都会有 <code>Flush</code> 队列进行渲染队列优化，但是有些老版本的浏览器比如IE6的效率依然低下。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="keyword">var</span> left = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">var</span> top = <span class="number">10</span>;</span><br><span class="line">el.style.left = left + <span class="string">"px"</span>;</span><br><span class="line">el.style.top = top + <span class="string">"px"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当top和left的值是动态计算而成时...</span></span><br><span class="line"><span class="comment">// better </span></span><br><span class="line">el.style.cssText += <span class="string">"; left: "</span> + left + <span class="string">"px; top: "</span> + top + <span class="string">"px;"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// better</span></span><br><span class="line">el.className += <span class="string">" className"</span>;</span><br></pre></td></tr></table></figure><h4 id="2-分离读写操作"><a href="#2-分离读写操作" class="headerlink" title="2.分离读写操作"></a>2.分离读写操作</h4><p>DOM 的多个读操作（或多个写操作），应该放在一起。不要两个读操作之间，加入一个写操作。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bad 强制刷新 触发四次重排+重绘</span></span><br><span class="line">div.style.left = div.offsetLeft + <span class="number">1</span> + <span class="string">'px'</span>;</span><br><span class="line">div.style.top = div.offsetTop + <span class="number">1</span> + <span class="string">'px'</span>;</span><br><span class="line">div.style.right = div.offsetRight + <span class="number">1</span> + <span class="string">'px'</span>;</span><br><span class="line">div.style.bottom = div.offsetBottom + <span class="number">1</span> + <span class="string">'px'</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// good 缓存布局信息 相当于读写分离 触发一次重排+重绘</span></span><br><span class="line"><span class="keyword">var</span> curLeft = div.offsetLeft;</span><br><span class="line"><span class="keyword">var</span> curTop = div.offsetTop;</span><br><span class="line"><span class="keyword">var</span> curRight = div.offsetRight;</span><br><span class="line"><span class="keyword">var</span> curBottom = div.offsetBottom;</span><br><span class="line"></span><br><span class="line">div.style.left = curLeft + <span class="number">1</span> + <span class="string">'px'</span>;</span><br><span class="line">div.style.top = curTop + <span class="number">1</span> + <span class="string">'px'</span>;</span><br><span class="line">div.style.right = curRight + <span class="number">1</span> + <span class="string">'px'</span>;</span><br><span class="line">div.style.bottom = curBottom + <span class="number">1</span> + <span class="string">'px'</span>;</span><br></pre></td></tr></table></figure><p>原来的操作会导致四次重排，读写分离之后实际上只触发了一次重排，这都得益于浏览器的渲染队列机制：</p><blockquote><p>当我们修改了元素的几何属性，导致浏览器触发重排或重绘时。它会把该操作放进渲染队列，等到队列中的操作到了一定的数量或者到了一定的时间间隔时，浏览器就会批量执行这些操作。</p></blockquote><h4 id="3-将-DOM-离线"><a href="#3-将-DOM-离线" class="headerlink" title="3.将 DOM 离线"></a>3.将 DOM 离线</h4><p>“离线”意味着不在当前的 DOM 树中做修改，我们可以这样做：</p><ul><li><p>使用 display:none</p><p>一旦我们给元素设置 <code>display:none</code> 时（只有一次重排重绘），元素便不会再存在在渲染树中，相当于将其从页面上“拿掉”，我们之后的操作将不会触发重排和重绘，添加足够多的变更后，通过 <code>display</code>属性显示（另一次重排重绘）。通过这种方式即使大量变更也只触发两次重排。另外，<code>visibility : hidden</code> 的元素只对重绘有影响，不影响重排。</p></li><li><p>通过 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/DocumentFragment" target="_blank" rel="external nofollow noopener noreferrer">documentFragment</a> 创建一个 <code>dom</code> 碎片,在它上面批量操作 <code>dom</code>，操作完成之后，再添加到文档中，这样只会触发一次重排。</p></li><li><p>复制节点，在副本上工作，然后替换它！</p></li></ul><h4 id="4-使用-absolute-或-fixed-脱离文档流"><a href="#4-使用-absolute-或-fixed-脱离文档流" class="headerlink" title="4.使用 absolute 或 fixed 脱离文档流"></a>4.使用 absolute 或 fixed 脱离文档流</h4><p>使用绝对定位会使的该元素单独成为渲染树中 <code>body</code> 的一个子元素，重排开销比较小，不会对其它节点造成太多影响。当你在这些节点上放置这个元素时，一些其它在这个区域内的节点可能需要重绘，但是不需要重排。</p><h4 id="5-优化动画"><a href="#5-优化动画" class="headerlink" title="5.优化动画"></a>5.优化动画</h4><ul><li><p>可以把动画效果应用到 <code>position</code>属性为 <code>absolute</code> 或 <code>fixed</code> 的元素上，这样对其他元素影响较小。</p><p>动画效果还应牺牲一些平滑，来换取速度，这中间的度自己衡量：<br>比如实现一个动画，以1个像素为单位移动这样最平滑，但是Layout就会过于频繁，大量消耗CPU资源，如果以3个像素为单位移动则会好很多</p></li><li><p>启用GPU加速<br><code>GPU</code> 硬件加速是指应用 <code>GPU</code> 的图形性能对浏览器中的一些图形操作交给 <code>GPU</code> 来完成，因为 <code>GPU</code> 是专门为处理图形而设计，所以它在速度和能耗上更有效率。</p><p><code>GPU</code> 加速通常包括以下几个部分：Canvas2D，布局合成, CSS3转换（transitions），CSS3 3D变换（transforms），WebGL和视频(video)。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 根据上面的结论</span></span><br><span class="line"><span class="comment">* 将 2d transform 换成 3d</span></span><br><span class="line"><span class="comment">* 就可以强制开启 GPU 加速</span></span><br><span class="line"><span class="comment">* 提高动画性能</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">div &#123;</span><br><span class="line">  transform: translate3d(<span class="number">10</span>px, <span class="number">10</span>px, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="如何在浏览器中查看页面渲染时间"><a href="#如何在浏览器中查看页面渲染时间" class="headerlink" title="如何在浏览器中查看页面渲染时间"></a>如何在浏览器中查看页面渲染时间</h2><p>1.打开开发者工具：点击 Performance 左侧有个小圆点 点击刷新页面会录制整个页面加载出来 时间的分配情况。如下图</p><p><img src="/uploads/i3_3.png" alt="image"></p><ul><li>蓝色: 网络通信和HTML解析</li><li>黄色: JavaScript执行</li><li>紫色: 样式计算和布局，即重排</li><li>绿色: 重绘</li></ul><p>哪种色块比较多，就说明性能耗费在那里。色块越长，问题越大。</p><p>2.点击 Event Log：单独勾选 Loading 项会显示 html 和 css 加载时间。如下图：</p><p><img src="/uploads/i3_4.png" alt="image"></p><p>3.解析完 DOM+CSSOM 之后会生成一个渲染树 Render Tree，就是 DOM 和 CSSOM 的一一对应关系。</p><p>4.通过渲染树中在屏幕上“画”出的所有节点，称为渲染。</p><h3 id="小结："><a href="#小结：" class="headerlink" title="小结："></a>小结：</h3><ul><li>渲染的三个阶段 Layout，Paint，Composite Layers。<br>Layout：重排，又叫回流。<br>Paint:重绘，重排重绘这些步骤都是在 CPU 中发生的。<br>Compostite Layers：CPU 把生成的 BitMap（位图）传输到 GPU，渲染到屏幕。 </li><li>CSS3 就是在 GPU 发生的：Transform  Opacity。在 GPU 发生的属性比较高效。所以 CSS3 性能比较高。</li></ul><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>非常感谢你看完了这篇很长的文章，也希望大家能重视重排的这些问题，在我们平时的开发中，也需要有意识的规避这些问题，才能让我们写出来的代码更规范！</p><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p><a href="https://segmentfault.com/a/1190000017491520" target="_blank" rel="external nofollow noopener noreferrer">掌握浏览器重绘(repaint)重排(reflow))-前端进阶</a><br><a href="https://csstriggers.com" target="_blank" rel="external nofollow noopener noreferrer">csstriggers</a><br><a href="https://efe.baidu.com/blog/hardware-accelerated-css-the-nice-vs-the-naughty/" target="_blank" rel="external nofollow noopener noreferrer">CSS硬件加速的好与坏</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/uploads/i3_1.jpg&quot; alt=&quot;image&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="前端" scheme="https://litgod.net/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="CSS" scheme="https://litgod.net/tags/CSS/"/>
    
      <category term="HTML" scheme="https://litgod.net/tags/HTML/"/>
    
  </entry>
  
  <entry>
    <title>浅谈 this、call、apply 和 bind</title>
    <link href="https://litgod.net/2020/01/19/%E5%85%B3%E4%BA%8E-this%E3%80%81call%E3%80%81apply-%E5%92%8C-bind-%E7%9A%84%E4%B8%80%E4%BA%9B%E7%90%86%E8%A7%A3/"/>
    <id>https://litgod.net/2020/01/19/%E5%85%B3%E4%BA%8E-this%E3%80%81call%E3%80%81apply-%E5%92%8C-bind-%E7%9A%84%E4%B8%80%E4%BA%9B%E7%90%86%E8%A7%A3/</id>
    <published>2020-01-19T06:41:18.000Z</published>
    <updated>2020-05-23T13:11:26.399Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/uploads/i2_1.jpg" alt="image"></p><a id="more"></a><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这是一个前端面试经常考的基础考点，很多初学者在这个问题上都容易踩坑，包括我也是经常性蒙圈。所以这次决定将他们梳理下来，加深自己的理解。如果有出错的地方，欢迎指正。</p><h2 id="this-是什么"><a href="#this-是什么" class="headerlink" title="this 是什么"></a>this 是什么</h2><p>this 关键字是 Javascript ES5 中最复杂的机制之一。<a href="http://es6.ruanyifeng.com/#README" target="_blank" rel="external nofollow noopener noreferrer">ES6</a> 中新增的箭头函数，很大程度上避免了使用 this 所产生的错误。但是在 ES5 中，有时候我们会错误的判断了 this 的指向。其实关于 this 的指向，始终坚持一个原理：<strong>this 永远指向最后调用它的那个对象</strong>，记住了这句话，this 的指向你已经了解一半！</p><p>想要了解 this 的指向，我们首先要了解 this 的四种绑定方式：<strong>隐式绑定、显示绑定、window 绑定、new 绑定</strong>。</p><h2 id="this-的四种绑定方式"><a href="#this-的四种绑定方式" class="headerlink" title="this 的四种绑定方式"></a>this 的四种绑定方式</h2><h3 id="隐式绑定"><a href="#隐式绑定" class="headerlink" title="隐式绑定"></a>隐式绑定</h3><p>执行绑定的第一个也是最常见的规则为 <strong>隐式绑定</strong>，它 80% 的情况下会告诉你 this 指向的对象是什么。</p><p>我们先来看一个简单的例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const user = &#123;</span><br><span class="line">  name: &apos;Cherry&apos;,</span><br><span class="line">  age: 27,</span><br><span class="line">  getName() &#123;</span><br><span class="line">    console.log(`Hello, my name is $&#123;this.name&#125;`)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">user.getName()  // Hello, my name is Cherry</span><br></pre></td></tr></table></figure><p>当我们执行 <code>user.getName()</code> 时，会打印出<code>Hello, my name is Cherry</code>。</p><p>如果你要调用 <strong>user</strong> 对象上的  <strong>getName</strong> 方法，你会用到点<code>.</code></p><p>这就是所谓隐式绑定，<strong>函数被调用时先看一看点号左侧</strong>。如果有“点”就查看“点”左侧的对象，这个对象就是 <strong>this</strong> 的引用。</p><p>在上面的例子中，<strong>user</strong> 在“点号左侧”意味着 <strong>this</strong> 引用了 <strong>user</strong> 对象。所以就好像 在 <strong>getName</strong> 方法的内部 <strong>JavaScript</strong> 解释器把 <strong>this</strong> 变成了 <strong>user</strong>。</p><p>所以，你可以得出这样的结论：<strong>使用对象来调用其内部的一个方法，该方法的 this 是指向对象本身的</strong>。这就是所谓隐式绑定，你也可以这样认为：JavaScript解释器在执行 <code>user.getName()</code>时，将其转化为了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">user.getName.call(user);</span><br></pre></td></tr></table></figure><p>我们将代码增加一层调用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">const user = &#123;</span><br><span class="line">  name: &apos;Cherry&apos;,</span><br><span class="line">  age: 27,</span><br><span class="line">  getName() &#123;</span><br><span class="line">    console.log(`Hello, my name is $&#123;this.name&#125;`)</span><br><span class="line">  &#125;,</span><br><span class="line">  mother: &#123;</span><br><span class="line">    name: &apos;Susan&apos;,</span><br><span class="line">    getName() &#123;</span><br><span class="line">      console.log(`Hello, my name is $&#123;this.name&#125;`)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">user.getName()  // Hello, my name is Cherry</span><br><span class="line">user.mother.getName()    // Hello, my name is Susan</span><br></pre></td></tr></table></figure><p>正如刚才所说：<strong>this 永远指向最后调用它的那个对象</strong>，那么“点”左侧的对象即为后调用该方法的对象，this 指向该对象。但是，如果没有点呢？这就为我们引出了下一条规则：</p><h3 id="显示绑定"><a href="#显示绑定" class="headerlink" title="显示绑定"></a>显示绑定</h3><p>关于显示绑定，我们可以通过 call 来设置函数执行上下文的 this 指向，比如下面这段代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function getName () &#123;</span><br><span class="line">  console.log(`Hello, my name is $&#123;this.myName&#125;`)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let user = &#123;</span><br><span class="line">  myName: &apos;Cherry&apos;,</span><br><span class="line">  age: 27,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getName.call(user)  // Hello, my name is Cherry</span><br></pre></td></tr></table></figure><p>执行这段代码，然后观察输出结果，你会发现 getName 函数内部的 this 已经指向了 user 对象。</p><p>其实除了 call 方法，我们还可以使用 bind 和 apply 方法来设置函数执行上下文中的 this，它们在使用上有一些区别，文章的第六小节会对 call、apply、bind 进行详细的介绍，这里我就不过多赘述了。</p><h3 id="window-绑定"><a href="#window-绑定" class="headerlink" title="window 绑定"></a>window 绑定</h3><p>我们在刚才的例子的基础上修改一下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function getName () &#123;</span><br><span class="line">  console.log(`Hello, my name is $&#123;this.myName&#125;`)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let user = &#123;</span><br><span class="line">  myName: &apos;Cherry&apos;,</span><br><span class="line">  age: 27,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getName();</span><br></pre></td></tr></table></figure><p>相信大家都知道为什么打印出来的是 <strong>My name is undefined</strong>，因为正如前面所说的，如果你想用 <strong>user</strong> 做上下文调用 <strong>getName</strong>，你可以使用 <strong>.call</strong>、<strong>.apply</strong> 或 <strong>.bind</strong>。但如果我们没有用这些方法，而是直接和平时一样直接调用，<strong>JavaScript</strong> 会默认 <strong>this</strong> 指向 <strong>window</strong> 对象。但是 <strong>window</strong> 对象中并没有 <strong>myName</strong> 属性，所以会打印 <strong>“My name is undefined“</strong>。</p><blockquote><p>在 ES5 添加的 严格模式 中，JavaScript 不会默认 this 指向 window 对象，而会正确地把 this 保持为 undefined。</p></blockquote><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&apos;use strict&apos;</span><br><span class="line"></span><br><span class="line">age = 27</span><br><span class="line"></span><br><span class="line">function sayAge () &#123;</span><br><span class="line">  console.log(`Hello, my age is $&#123;this.age&#125;`)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sayAge() // TypeError: Cannot read property &apos;age&apos; of undefined</span><br></pre></td></tr></table></figure><h3 id="new-绑定"><a href="#new-绑定" class="headerlink" title="new 绑定"></a>new 绑定</h3><p>第四条判断 <strong>this</strong> 引用的规则是 <strong>new</strong> 绑定。每当用 <strong>new</strong> 调用函数时，<strong>JavaScript</strong> 解释器都会在底层创建一个全新的对象并把这个对象当做 <strong>this</strong>。</p><blockquote><p>这看起来就像创建了新的函数，但实际上 <strong>JavaScript</strong> 函数是重新创建的对象。</p></blockquote><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function User (name, age) &#123;</span><br><span class="line">  /*</span><br><span class="line">    JavaScript 会在底层创建一个新对象 `this`，它会代理不在 User 原型链上的属性。</span><br><span class="line">    如果一个函数用 new 关键字调用，this 就会指向解释器创建的新对象。</span><br><span class="line">  */</span><br><span class="line"></span><br><span class="line">  this.name = name</span><br><span class="line">  this.age = age</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const me = new User(&apos;Cherry&apos;, 27)</span><br></pre></td></tr></table></figure><p>伪代码表示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var me = new User(&quot;Cherry&quot;,&quot;27&quot;);</span><br><span class="line"></span><br><span class="line">new User&#123;</span><br><span class="line">  var object = &#123;&#125;;</span><br><span class="line">  object.__proto__ = User.prototype;</span><br><span class="line">  var result = User.call(object,&quot;Cherry&quot;,&quot;27&quot;);</span><br><span class="line">  return typeof result === &apos;object&apos;? result : object;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>new</strong> 的过程：<br>1.创建一个空对象 object;<br>2.将新创建的空对象的隐式原型指向其构造函数的显示原型；<br>3.使用 call 改变 this 的指向；<br>4.如果无返回值或者返回一个非对象值，则将 object 返回作为新对象；如果返回值是一个新对象的话那么直接直接返回该对象。</p><p>所以我们可以看到，在 new 的过程中，其实是使用 call 改变了 this 的指向。</p><h2 id="this-的指向"><a href="#this-的指向" class="headerlink" title="this 的指向"></a>this 的指向</h2><p>前面讲了关于 this 的四种绑定方式，我们对于 this 的指向应该也有了一些自己的理解，还记得我们之前说的吗？<strong>this 永远指向最后调用它的那个对象</strong>，我们记好这句话来练习下下面的例子：</p><p>例1:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var name = &quot;window&quot;;</span><br><span class="line">function fn() &#123;</span><br><span class="line">  var name = &quot;Cherry&quot;;</span><br><span class="line"></span><br><span class="line">  console.log(this.name);          // window</span><br><span class="line"></span><br><span class="line">  console.log(&quot;inner:&quot; + this);    // inner: Window</span><br><span class="line">&#125;</span><br><span class="line">fn();</span><br><span class="line">console.log(&quot;outer:&quot; + this)         // outer: Window</span><br></pre></td></tr></table></figure><p>我们看最后调用 <strong>fn</strong> 的地方 <code>fn();</code>，前面没有“点”，<strong>Javascript</strong> 调用的对象默认指向了全局对象 <strong>window</strong>，这就相当于是 <code>window.fn()；</code>所以根据刚刚的那句话“<strong>this 永远指向最后调用它的那个对象</strong>”，<strong>this</strong> 指向的就是 <strong>window</strong>。绑定规则是Window绑定。</p><blockquote><p>注意，这里我们没有使用严格模式，如果使用严格模式的话，全局对象就是 undefined，那么就会报错 Uncaught TypeError: Cannot read property ‘name’ of undefined。</p></blockquote><p>例2:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var name = &quot;window&quot;;</span><br><span class="line">var user = &#123;</span><br><span class="line">  name: &quot;Cherry&quot;,</span><br><span class="line">  fn: function () &#123;</span><br><span class="line">      console.log(this.name);      // Cherry</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">user.fn();</span><br></pre></td></tr></table></figure><p>根据上文所说，我们看到函数 <strong>fn</strong> 左侧有“点”，“点”的左侧是 <strong>user</strong>，所以 <strong>fn</strong> 是对象 <strong>user</strong> 调用的。所以打印的值就是 <strong>user</strong> 中的 <strong>name</strong> 的值。绑定规则是隐式绑定。</p><p>例3：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">var name = &quot;window&quot;;</span><br><span class="line"></span><br><span class="line">function fnA()&#123;</span><br><span class="line">  var name = &quot;Cherry&quot;;</span><br><span class="line"></span><br><span class="line">  function fnB()&#123;</span><br><span class="line">    console.log(this.name);    // window </span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  //在A函数内部调用B函数</span><br><span class="line">  fnB();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//调用A函数</span><br><span class="line">fnA();</span><br></pre></td></tr></table></figure><p><strong>嵌套函数中的 this 不会从外层函数中继承</strong>。在函数执行环境中使用 this 时,如果函数没有明显的作为非 window 对象的属性，而只是定义了函数，这个函数中的 this 仍然默认指向 window 对象。</p><p>例4:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var name = &quot;window&quot;;</span><br><span class="line">var user = &#123;</span><br><span class="line">  name: &quot;Cherry&quot;,</span><br><span class="line">  fn: function () &#123;</span><br><span class="line">    console.log(this.name);      // Cherry</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">window.user.fn();</span><br></pre></td></tr></table></figure><p>这里打印 Cherry 的原因也是因为刚刚那句话“this 永远指向最后调用它的那个对象”，最后调用它的对象仍然是对象 user。</p><p>我们改动一下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var name = &quot;window&quot;;</span><br><span class="line">var user = &#123;</span><br><span class="line">  // name: &quot;Cherry&quot;,</span><br><span class="line">  fn: function () &#123;</span><br><span class="line">    console.log(this.name);      // undefined</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">window.user.fn();</span><br></pre></td></tr></table></figure><p>这是因为调用 <strong>fn</strong> 的是 <strong>user</strong> 对象，也就是说 <strong>fn</strong> 的内部的 <strong>this</strong> 是对象 <strong>user</strong>，而对象 <strong>user</strong> 中并没有对 <strong>name</strong> 进行定义，所以 <strong>log</strong> 的 <strong>this.name</strong> 的值是 <strong>undefined</strong>。</p><p>这个例子还是说明了：<strong>this 永远指向最后调用它的那个对象</strong>，因为最后调用 <strong>fn</strong> 的对象是 <strong>user</strong>，所以就算 <strong>user</strong> 中没有 <strong>name</strong> 这个属性，也不会继续向上一个对象寻找 <strong>this.name</strong>，而是直接输出 <strong>undefined</strong>。</p><p>例5：（这个例子稍稍有点坑）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var name = &quot;window&quot;;</span><br><span class="line">var user = &#123;</span><br><span class="line">  name : null,</span><br><span class="line">  // name: &quot;Cherry&quot;,</span><br><span class="line">  fn : function () &#123;</span><br><span class="line">    console.log(this.name);      // window</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var f = user.fn;</span><br><span class="line">f();</span><br></pre></td></tr></table></figure><p>这里你可能会有疑问，为什么不是 Cherry？因为这里虽然将 <strong>user</strong> 对象的 <code>fn</code> 方法赋值给变量 <code>f</code> 了，但是<strong>没有调用</strong>，再接着跟我念这一句话：“<strong>this 永远指向最后调用它的那个对象</strong>”，由于刚刚的 <code>f</code> 并没有调用，所以 <code>fn()</code> 最后仍然是被 <strong>window</strong> 调用的。所以 <strong>this</strong> 指向的也就是 <strong>window</strong>。</p><p>由以上五个例子我们可以看出，this 的指向并不是在创建的时候就可以确定的，在 es5 中，<strong>this永远指向最后调用它的那个对象。</strong></p><h2 id="如何改变-this-的指向"><a href="#如何改变-this-的指向" class="headerlink" title="如何改变 this 的指向"></a>如何改变 this 的指向</h2><p>改变 this 的指向我总结有以下几种方法：</p><ul><li>使用 ES6 的箭头函数</li><li>在函数内部使用 _this = this</li><li>使用 apply、call、bind</li><li>new 实例化一个对象</li></ul><p>我们看下面的例子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">var name = &quot;window&quot;;</span><br><span class="line"></span><br><span class="line">var user = &#123;</span><br><span class="line">  name : &quot;Cherry&quot;,</span><br><span class="line"></span><br><span class="line">  fn1: function() &#123;</span><br><span class="line">    console.log(this.name)     </span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  fn2: function() &#123;</span><br><span class="line">    setTimeout(function () &#123;</span><br><span class="line">      this.fn1()</span><br><span class="line">    &#125;,100);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">user.fn2()     // this.fn1 is not a function</span><br></pre></td></tr></table></figure><p>我们逐一细说一下这个例子：<code>fn2()</code>是被 <strong>user</strong>调用的，所以<code>fn2</code>中的 <strong>this</strong> 应该指向 <strong>user</strong>。但是<code>fn2</code>中又调用了 <strong>window</strong> 中的 <strong>setTimeout</strong> 方法。所以在 <strong>setTimeout</strong> 方法中的 <strong>this</strong> 指向的是后调用它的对象 <strong>window</strong>。但是在 <strong>window</strong> 中并没有 <strong>fn1</strong> 函数。所以抛出错误：this.fn1 is not a function。</p><p>如果我们想正确的调用 <strong>user</strong> 中的 <code>fn1()</code>，应该怎么做呢？我们把这个例子作为 demo 进行改造。</p><h3 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h3><p>众所周知，ES6 的箭头函数是可以避免 ES5 中使用 this 的坑的。“所有的箭头函数都没有自己的this，都指向外层。”–这句话就是箭头函数的精髓。箭头函数的this，总是指向定义时所在的对象，而不是运行时所在的对象。这句话说的太模糊了，最好改成：<strong>总是指向所在函数运行时的this</strong>。</p><p>上面例子我们使用<strong>箭头函数</strong>改变this的指向如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">var name = &quot;window&quot;;</span><br><span class="line"></span><br><span class="line">var user = &#123;</span><br><span class="line">  name : &quot;Cherry&quot;,</span><br><span class="line"></span><br><span class="line">  fn1: function () &#123;</span><br><span class="line">    console.log(this.name)     </span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  fn2: function () &#123;</span><br><span class="line">    setTimeout( () =&gt; &#123;</span><br><span class="line">        this.fn1()</span><br><span class="line">    &#125;,100);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">user.fn2()     // Cherry</span><br></pre></td></tr></table></figure><h3 id="在函数内部使用-this-this"><a href="#在函数内部使用-this-this" class="headerlink" title="在函数内部使用 _this = this"></a>在函数内部使用 _this = this</h3><p>如果不使用 ES6，那么这种方式应该是最简单的不会出错的方式了，我们是先将调用这个函数的对象保存在变量 _this 中，然后在函数中都使用这个 _this，这样 _this 就不会改变了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">var name = &quot;window&quot;;</span><br><span class="line"></span><br><span class="line">var user = &#123;</span><br><span class="line"></span><br><span class="line">  name : &quot;Cherry&quot;,</span><br><span class="line"></span><br><span class="line">  fn1: function () &#123;</span><br><span class="line">    console.log(this.name)     </span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  fn2: function () &#123;</span><br><span class="line">    var _this = this;</span><br><span class="line">    setTimeout( function() &#123;</span><br><span class="line">      _this.fn1()</span><br><span class="line">    &#125;,100);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">user.fn2()       // Cherry</span><br></pre></td></tr></table></figure><p>这个例子中，在 fn2 中，首先设置 var _this = this;，这里的 <strong>this</strong> 是调用 <code>fn2</code> 的对象 <strong>user</strong>，为了防止在 <code>fn2</code> 中的 <strong>setTimeout</strong> 被 <strong>window</strong> 调用而导致的在 <strong>setTimeout</strong> 中的 <strong>this</strong> 为 <strong>window</strong>。我们将 <strong>this</strong>(指向变量 user) 赋值给一个变量 <strong>_this</strong>，这样，在 <code>fn2</code> 中我们使用 <strong>_this</strong> 就是指向对象 <strong>user</strong> 了。</p><h3 id="使用-apply、call、bind"><a href="#使用-apply、call、bind" class="headerlink" title="使用 apply、call、bind"></a>使用 apply、call、bind</h3><p>使用 apply、call、bind 函数也是可以改变 this 的指向的，成为显示绑定，我们先来看一下是怎么实现的：</p><h4 id="使用-apply"><a href="#使用-apply" class="headerlink" title="使用 apply()"></a>使用 apply()</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">var user = &#123;</span><br><span class="line">  name: &quot;Cherry&quot;,</span><br><span class="line"></span><br><span class="line">  fn1: function() &#123;</span><br><span class="line">    console.log(this.name)</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  fn2: function() &#123;</span><br><span class="line">    setTimeout(function () &#123;</span><br><span class="line">      this.fn1()</span><br><span class="line">    &#125;.apply(user), 100);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">user.fn2()            // Cherry</span><br></pre></td></tr></table></figure><h4 id="使用-call"><a href="#使用-call" class="headerlink" title="使用 call()"></a>使用 call()</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">var user = &#123;</span><br><span class="line">  name: &quot;Cherry&quot;,</span><br><span class="line"></span><br><span class="line">  fn1: function() &#123;</span><br><span class="line">    console.log(this.name)</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  fn2: function() &#123;</span><br><span class="line">    setTimeout(function () &#123;</span><br><span class="line">      this.fn1()</span><br><span class="line">    &#125;.call(user), 100);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">user.fn2()            // Cherry</span><br></pre></td></tr></table></figure><h4 id="使用-bind"><a href="#使用-bind" class="headerlink" title="使用 bind()"></a>使用 bind()</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">var user = &#123;</span><br><span class="line">  name: &quot;Cherry&quot;,</span><br><span class="line"></span><br><span class="line">  fn1: function() &#123;</span><br><span class="line">    console.log(this.name)</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  fn2: function() &#123;</span><br><span class="line">    setTimeout(function () &#123;</span><br><span class="line">      this.fn1()</span><br><span class="line">    &#125;.bind(user)(), 100);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">user.fn2()            // Cherry</span><br></pre></td></tr></table></figure><h2 id="apply、call、bind-的区别"><a href="#apply、call、bind-的区别" class="headerlink" title="apply、call、bind 的区别"></a>apply、call、bind 的区别</h2><p>刚刚我们已经介绍了 apply、call、bind 都是可以改变 this 的指向的，但是这三个函数稍有不同。</p><p>在 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/apply" target="_blank" rel="external nofollow noopener noreferrer">MDN</a> 中定义 apply 如下；</p><blockquote><p>apply() 方法调用一个函数, 其具有一个指定的this值，以及作为一个数组（或类似数组的对象）提供的参数</p></blockquote><h3 id="apply-和-call-的区别"><a href="#apply-和-call-的区别" class="headerlink" title="apply 和 call 的区别"></a>apply 和 call 的区别</h3><p>其实 apply 和 call 基本类似，他们的区别只是传入的参数不同。</p><p>call 的语法为: </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fun.call(thisArg[, arg1[, arg2[, ...]]])</span><br></pre></td></tr></table></figure><p>所以 apply 和 call 的区别是 call 方法接受的是若干个参数列表，而 apply 接收的是一个包含多个参数的数组。</p><p>apply()的使用方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var user =&#123;</span><br><span class="line">  name: &quot;Cherry&quot;,</span><br><span class="line">  fn: function(a,b) &#123;</span><br><span class="line">    console.log(a + b)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var newUser = user.fn;</span><br><span class="line">newUser.apply(user,[1,2])     // 3</span><br></pre></td></tr></table></figure><p>call()的使用方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var user =&#123;</span><br><span class="line">  name: &quot;Cherry&quot;,</span><br><span class="line">  fn: function(a,b) &#123;</span><br><span class="line">    console.log(a + b)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var newUser =user.fn;</span><br><span class="line">newUser.call(user, 1, 2)       // 3</span><br></pre></td></tr></table></figure><p>但凡事都有例外：<br>若将null、undefined等值作为call、apply的第一个参数，那么实际调用时会被忽略，从而应用到Window绑定规则，即绑定到window上，有些时候我们不关心上下文，只关心参数时，可以这样做。</p><p>但这样其实存在这一些潜在的风险，绑定到window很可能无意中添加或修改了全局变量，造成一些隐蔽的bug。所以为了防止这种情况出现，可以将第一个参数绑定为一个空对象。当然具体还是看需求，这只是建议。</p><h3 id="bind-和-apply、call-区别"><a href="#bind-和-apply、call-区别" class="headerlink" title="bind 和 apply、call 区别"></a>bind 和 apply、call 区别</h3><p>我们先使用 bind 试一下刚刚的例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var user =&#123;</span><br><span class="line">  name: &quot;Cherry&quot;,</span><br><span class="line">  fn: function(a,b) &#123;</span><br><span class="line">    console.log(a + b)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var newUser = user.fn;</span><br><span class="line">nreUser.bind(user,1,2)</span><br></pre></td></tr></table></figure><p>我们会发现并没有输出，这是为什么呢，我们来看一下 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/bind" target="_blank" rel="external nofollow noopener noreferrer">MDN</a> 上的文档说明：</p><blockquote><p>bind()方法创建一个新的函数, 当被调用时，将其this关键字设置为提供的值，在调用新函数时，在任何提供之前提供一个给定的参数序列。</p></blockquote><p>所以我们可以看出，<strong>bind 是创建一个新的函数</strong>，我们必须要手动去调用:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var user =&#123;</span><br><span class="line">  name: &quot;Cherry&quot;,</span><br><span class="line">  fn: function (a,b) &#123;</span><br><span class="line">    console.log( a + b)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var newUser = user.fn;</span><br><span class="line">newUser.bind(user,1,2)()           // 3</span><br></pre></td></tr></table></figure><p>以上就是三种显示绑定的方法，但有三点需要注意：</p><ol><li>call和apply是立即执行，bind则是返回一个绑定了this的新函数，只有你调用了这个新函数才真的调用了目标函数</li><li>bind函数存在多次绑定的问题，如果多次绑定this，则以第一次为准。</li><li>bind函数实际上是显示绑定（call、apply）的一个变种，称为<strong>硬绑定</strong>。由于硬绑定是一种非常常用的模式，所以在 ES5 中提供了内置的方法<code>Function.prototype.bind</code></li></ol><p>为什么多次使用bind绑定this，以第一次为准呢？我们看下面的例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function foo() &#123;</span><br><span class="line">  console.log( this.name );</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">var obj1 = &#123;</span><br><span class="line">  name: &apos;obj1&apos;</span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line">var obj2 = &#123;</span><br><span class="line">  name: &apos;obj2&apos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var fn = foo.bind(obj1).bind(obj2)</span><br><span class="line">fn() // =&gt; &apos;obj1&apos;</span><br><span class="line">fn.call(obj2) // =&gt; &apos;obj1&apos;</span><br></pre></td></tr></table></figure><p>也就是说bind函数只能绑定一次，多次绑定是没有用的，绑定后的函数this无法改变，即使call/apply也不行，所以才称作硬绑定。</p><p>但凡事总有例外，且看new绑定。</p><h2 id="绑定的优先级"><a href="#绑定的优先级" class="headerlink" title="绑定的优先级"></a>绑定的优先级</h2><p>如果显示绑定和new绑定同时存在，或者更宽泛的说：<strong>在某个调用位置多条绑定规则同时存在怎么办呢</strong>？为了解决这个问题就必须给这些规则设定优先级，这就是我们接下来要介绍的内容。</p><p>毫无疑问，Window绑定的优先级是最低的，显式绑定和隐式绑定的优先级，通过上面的例子也可以证明，显式大于隐式。所以目前顺序是：<code>显式 &gt; 隐式 &gt; Window</code></p><p>那我们来测试下显示绑定和new绑定的优先级顺序。由于call/apply无法和new一起使用，我们可以使用bind（硬绑定）来验证。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function foo() &#123;</span><br><span class="line">  this.name = &apos;Cherry&apos;;</span><br><span class="line">&#125; </span><br><span class="line">var obj = &#123;</span><br><span class="line">  name: &apos;obj&apos;</span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line">var fn = foo.bind(obj)</span><br><span class="line">var result = new fn()</span><br><span class="line">console.log(obj.name) // =&gt; &apos;obj&apos;</span><br><span class="line">console.log(result.name) // =&gt; &apos;Cherry&apos;</span><br></pre></td></tr></table></figure><p>显而易见的，new的优先级，大于显示绑定。最终顺序为：<code>new &gt; 显式 &gt; 隐式 &gt; Window</code>。</p><p>于是我们判断this，就有了一个顺序：</p><ol><li>函数是否在new中调用？</li><li>是否通过call、apply、bind等调用？</li><li>是否在某个上下文对象中调用？</li><li>都不是则是Window绑定。且严格模式下绑定到undefined。</li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>判断this主要有以下步骤：</p><ol><li>函数是否在new中调用？</li><li>是否通过call、apply、bind等调用？</li><li>是否在某个上下文对象中调用？</li><li>都不是则是默认绑定。且严格模式下绑定到undefined。</li></ol><p>另外还要注意箭头函数的特殊性以及undefined和null会被忽略这一特性。还有这一句：this永远指向最后调用它的那个对象。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/uploads/i2_1.jpg&quot; alt=&quot;image&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="前端" scheme="https://litgod.net/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>超详细的Github+Hexo搭建教程</title>
    <link href="https://litgod.net/2019/10/31/%E8%B6%85%E8%AF%A6%E7%BB%86%E7%9A%84Github-Hexo%E6%90%AD%E5%BB%BA%E6%95%99%E7%A8%8B/"/>
    <id>https://litgod.net/2019/10/31/%E8%B6%85%E8%AF%A6%E7%BB%86%E7%9A%84Github-Hexo%E6%90%AD%E5%BB%BA%E6%95%99%E7%A8%8B/</id>
    <published>2019-10-31T12:45:02.000Z</published>
    <updated>2020-03-10T02:26:54.819Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/uploads/hexo.jpg" alt="image"></p><a id="more"></a><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>不管你是程序猿（媛），产品经理，设计师，运维工程师…还是从事其他职业，应该都想拥有一个属于自己的个人博客网站吧。如果你是，那么请跟随目录，搭建属于你的个人博客吧!一起来技术分享，记录生活…</p><h2 id="Hexo-是什么"><a href="#Hexo-是什么" class="headerlink" title="Hexo 是什么"></a>Hexo 是什么</h2><p><a href="https://hexo.io" target="_blank" rel="external nofollow noopener noreferrer">Hexo</a> 是一个基于 <a href="https://nodejs.org/en" target="_blank" rel="external nofollow noopener noreferrer">Node.js</a>的快速，简单月功能强大的博客框架。可以使用简单的命令生成静态网页，并托管到 Github 上。<br>#TODO</p><h2 id="来搭建属于你的个人博客吧～"><a href="#来搭建属于你的个人博客吧～" class="headerlink" title="来搭建属于你的个人博客吧～"></a>来搭建属于你的个人博客吧～</h2><h3 id="Gihub-创建个人仓库"><a href="#Gihub-创建个人仓库" class="headerlink" title="Gihub 创建个人仓库"></a>Gihub 创建个人仓库</h3><ul><li><p>首先先登录到 <a href="https://github.com" target="_blank" rel="external nofollow noopener noreferrer">Github</a>。如果没有个人账号，先进行注册，注册完成后，点击登录进入 Github。</p></li><li><p>点击绿色的 <strong>New</strong> 按钮新建一个仓库，将仓库名称命为： 用户名.github.io，例如：qiruohan.github.io，这个写法是固定的。<br><img src="/uploads/i_1.jpg" alt="image"><br><img src="/uploads/i_2.jpg" alt="image"></p></li><li><p>注意：仓库名称要和你的用户名保持一致，后缀.github.io 的作用是 Github 识别到.github.io 后缀就会为你自动开启<a href="https://pages.github.com/" target="_blank" rel="external nofollow noopener noreferrer">Github Page</a>，作为你个人博客的仓库。</p></li></ul><p>然后项目就建成了，点击Settings，向下拉到最后有个GitHub Pages，点击Choose a theme可以选择一个主题。然后点击那个链接，就会出现自己的网页啦～</p><h3 id="安装-Node-js"><a href="#安装-Node-js" class="headerlink" title="安装 Node.js"></a>安装 Node.js</h3><p>Node.js 是基于 <a href="https://v8.dev/" target="_blank" rel="external nofollow noopener noreferrer">Chrome V8 JavaScript 引擎</a> 构建的语言，是一项服务器端技术。<br>下载地址：<a href="https://nodejs.org/en/download/" target="_blank" rel="external nofollow noopener noreferrer">Node.js | Download</a>，下载当前操作系统的安装包，安装选项全部默认。注意下载的安装包中已经包含了环境变量以及 <a href="https://www.npmjs.com/" target="_blank" rel="external nofollow noopener noreferrer">npm</a>，所以安装完安装包后无需另外再下载 npm。</p><p>检测 Node.js 是否安装成功，在命令行中输入：<strong>node -v</strong><br><img src="/uploads/i_3.png" alt="image"></p><p>检测 npm 是否安装成功，在命令行中输入：<strong>npm -v</strong><br><img src="/uploads/i_4.png" alt="image"></p><p>显示版本号，那么就说明 node.js 安装成功了。</p><h3 id="安装-Git"><a href="#安装-Git" class="headerlink" title="安装 Git"></a>安装 Git</h3><p><a href="https://git-scm.com/" target="_blank" rel="external nofollow noopener noreferrer">Git</a> 是一个开源的分布式版本控制系统，旨在快速高效地处理从小型到大型项目的所有内容。具有便捷的创建本地分支，创建暂存区域，处理多个工作流等功能。简单来说，使用 Git 可以把本地文件同步到 Github 上，完成多人多空间的便捷式管理。</p><p><strong>Windows 下</strong>安装下载地址：<a href="https://git-scm.com/download/" target="_blank" rel="external nofollow noopener noreferrer">Git | Downloads</a>，安装选项还是全部默认，安装完成后在命令行中输入 <strong>git –version</strong> 验证是否安装成功。<br><img src="/uploads/i_5.png" alt="image"><br>显示版本号，那么就说明 git 安装成功了。安装成功后，将你的Git与GitHub帐号绑定，鼠标右击打开Git Bash，设置user.name和user.email配置信息。<br>之后移步到 mac 下安装流程的<strong>第三步：设置github的 username 和 email</strong>，做接来下的操作。</p><p><strong>Mac 下安装</strong>：</p><ul><li><p>如果未安 homebrew，需要先安装 homebrew</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;</span><br></pre></td></tr></table></figure></li><li><p>安装 git</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install git</span><br></pre></td></tr></table></figure></li><li><p>检查 git 是否安装成功</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git --version</span><br></pre></td></tr></table></figure></li><li><p>安装成功后，先设置github的 username 和 email（github 在每次提交的时候都会记录他们）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name &quot;你的GitHub用户名&quot;</span><br><span class="line">git config --global user.email &quot;你的GitHub注册邮箱&quot;</span><br></pre></td></tr></table></figure></li><li><p>使用终端命令创建 ssh key</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;你的GitHub注册邮箱&quot;</span><br></pre></td></tr></table></figure><p>然后直接三个回车即可，默认不需要设置密码<br>然后找到生成的.ssh的文件夹中的id_rsa.pub密钥，将内容全部复制</p></li><li><p>打开 <a href="https://github.com/settings/keys" target="_blank" rel="external nofollow noopener noreferrer">GitHub_Settings_keys</a> 页面，新建new SSH Key<br><img src="/uploads/i_10.png" alt="image"></p></li></ul><p>Title为标题，任意填即可，将刚刚复制的id_rsa.pub内容粘贴进去，最后点击Add SSH key。</p><ul><li>在终端检测GitHub公钥设置是否成功，输入 ssh <a href="mailto:git@github.com" target="_blank" rel="external nofollow noopener noreferrer">git@github.com</a>。<br><img src="/uploads/i_11.png" alt="image"></li></ul><p>如上则说明成功。</p><p>注意：这里之所以设置GitHub密钥原因是，通过非对称加密的公钥与私钥来完成加密，公钥放置在GitHub上，私钥放置在自己的电脑里。GitHub要求每次推送代码都是合法用户，所以每次推送都需要输入账号密码验证推送用户是否是合法用户，为了省去每次输入密码的步骤，采用了ssh，当你推送的时候，git就会匹配你的私钥跟GitHub上面的公钥是否是配对的，若是匹配就认为你是合法用户，则允许推送。这样可以保证每次的推送都是正确合法的。</p><h3 id="安装-Hexo"><a href="#安装-Hexo" class="headerlink" title="安装 Hexo"></a>安装 Hexo</h3><p>Hexo 就是我们搭建个人博客所使用的框架，我们需要在合适的地方先创建一个文件夹，用来存放自己的博客文件，例如我命名为blog2。</p><p>使用命令行进入到该目录下，输入 <code>npm i hexo-cli -g</code> 安装 Hexo，安装成功后，会显示安装所使用的总时长。<br><img src="/uploads/i_6.png" alt="image"></p><p>安装完成后，初始化我们的博客，输入 <code>hexo init blog</code>。<br>注意：这里的命令都作用在刚刚创建的 blog2 文件夹下。<br><img src="/uploads/i_7.png" alt="image"></p><p>初始化时间可能会比较长，耐心等待…<br><img src="/uploads/i_8.png" alt="image"></p><p>初始化完成后，会发现 blog2 下又新增了一个文件夹，名为 blog，与 <code>hexo init</code> 后面输入的文件名同名。我们进入新创建的文件夹 blog 下，输入以下三条命名来检测一下我们的网站雏形</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">hexo new test</span><br><span class="line"></span><br><span class="line">hexo g</span><br><span class="line"></span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure><p><img src="/uploads/i_9.png" alt="image"></p><p>到这里，我们的个人博客就搭建完成啦！并且已经写出了我们的第一篇文章～</p><h3 id="hexo-常用命令"><a href="#hexo-常用命令" class="headerlink" title="hexo 常用命令"></a>hexo 常用命令</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">1.安装 Hexo</span><br><span class="line">  npm install hexo -g</span><br><span class="line">2.升级 Hexo</span><br><span class="line">  npm update hexo -g</span><br><span class="line">3.初始化博客</span><br><span class="line">  hexo init &quot;博客站点&quot;</span><br><span class="line">4.新建文章</span><br><span class="line">  hexo n &quot;我的博客&quot;  或  hexo new &quot;我的博客&quot; </span><br><span class="line">5.生成博客</span><br><span class="line">  hexo g  或 hexo generate</span><br><span class="line">6.启动服务</span><br><span class="line">  hexo s  或  hexo server</span><br><span class="line">7.部署博客</span><br><span class="line">  hexo d  或  hexo deploy</span><br><span class="line">8.更改端口</span><br><span class="line">  hexo server -p 5000</span><br><span class="line">9.自定义 IP</span><br><span class="line">  hexo server -i 192.168.1.1</span><br><span class="line">10.清除缓存，若是网页正常情况下可以忽略这条命令</span><br><span class="line">  hexo clean</span><br><span class="line">11.新建页面</span><br><span class="line">  hexo new page xxx</span><br></pre></td></tr></table></figure><h3 id="推送博客站点"><a href="#推送博客站点" class="headerlink" title="推送博客站点"></a>推送博客站点</h3><p>上图只是本地的预览，如果想让大家都看到你的博客，就得把项目放在公网上被大家访问。打开博客根目录下的_config.yml文件，这是博客的配置文件，在这里你可以修改与博客相关的各种信息。这个文件称之为<strong>站点配置文件</strong>。<br><img src="/uploads/i_12.png" alt="image"></p><p>修改最后一行的配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: https://github.com/qiruohan/qiruohan.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure><p>repository修改为你自己的github项目地址。</p><p>这里其实就是给 hexo d 命令做相应的配置，让 hexo 知道要把你的博客部署在哪个位置，我们需要把项目部署到我们自己的GitHub的仓库里。</p><p>安装Git部署插件，输入命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><p>这时，我们分别输入三条命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean </span><br><span class="line">hexo g </span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure><p>打开浏览器，在地址栏输入你的放置个人网站的仓库路径，即 xxxx.github.io, 比如我的：qiruohan.github.io， 你就会发现你的博客已经上线了，可以在网络上被访问了。</p><h3 id="更换主题"><a href="#更换主题" class="headerlink" title="更换主题"></a>更换主题</h3><p>如果你不喜欢 Hexo 的默认主题，可以更换主题，hexo主题有很多，你可以从网上找到很多很好看的主题，每个主题也都有自己的安装教程，你可以试着看一看。</p><p>我这里使用的主题是<a href="https://theme-next.iissnan.com/" target="_blank" rel="external nofollow noopener noreferrer">nexT</a>，所以我说一下我的安装配置吧～</p><ul><li><p>安装 nexT 主题，通过 git 命令将 nexT 克隆下来， 在博客站点目录下（我的是blog），使用 git clone 命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/theme-next/hexo-theme-next themes/next</span><br></pre></td></tr></table></figure></li><li><p>等待克隆完毕，找到 themes 文件夹下的 next 文件， 这就是我们刚刚克隆下来的主题了。<br><img src="/uploads/i_13.png" alt="image"></p></li><li><p>返回根目录，找到我们的站点文件_config.yml，打开并修改里面的 theme 配置以使我们刚刚克隆下来的主题生效。</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">theme: next</span><br></pre></td></tr></table></figure><p>修改theme: landscape为next，注意theme和next之间要有空格，否则无效。</p><p>正确设置好后，我们更换的主题就生效啦～每个主题都可以有自己个性化的配置，可以打开主题的_config.yml配置文件（注意不是站点配置文件），可以按照你的想法做一些个性化的配置，之后再次部署网站，hexo clean、hexo g、hexo d，查看效果。选择其他主题，按照上述过程即可实现。</p><h3 id="发布文章"><a href="#发布文章" class="headerlink" title="发布文章"></a>发布文章</h3><p>1.文章头设置</p><h3 id="MarkDown-语法"><a href="#MarkDown-语法" class="headerlink" title="MarkDown 语法"></a>MarkDown 语法</h3><p>Markdown是一种可以使用普通文本编辑器编写的标记语言，通过简单的标记语法，具体语法参看：<a href="https://www.appinn.com/markdown/" target="_blank" rel="external nofollow noopener noreferrer">Markdown 语法说明(简体中文版)</a> 可以说十分钟就可以入门，非常简单发方便。当然，选择一个好的Markdown编辑器也是非常重要的，mac版推荐使用 MacDown 或者直接使用 VsCode 编写 Markdown 文件， 非常方便。</p><h3 id="绑定域名"><a href="#绑定域名" class="headerlink" title="绑定域名"></a>绑定域名</h3><p>现在默认的域名还是xxx.github.io，而如果我们想使用个性化的域名，就需要绑定我们自己的域名，首先你需要购买一个域名，XX云都能买，国内主流的域名代理厂商也就阿里云和腾讯云。下面给大家演示阿里云的相关配置：</p><ul><li>登录阿里云，进入管理控制台的域名列表，找到你的个性化域名，进入解析</li></ul><p><img src="/uploads/i_14.png" alt="image"></p><ul><li>添加解析</li></ul><p><img src="/uploads/i_15.png" alt="image"></p><p>一共包括两条解析记录，记录类型都是CNAME，CNAME的记录值是：你的用户名.github.io，这里千万别弄错了。</p><ul><li>登录GitHub，进入之前创建的仓库，点击settings，设置Custom domain，输入你的域名，点击保存。<br><img src="/uploads/i_16.png" alt="image"></li></ul><p>注意：如果你把 Enforce HTTPS 钩上，github 会自动帮你升级为 https 的哦～</p><ul><li><p>这时候你的项目根目录应该会出现一个名为CNAME的文件了。如果没有的话，打开你本地博客/source目录，手动创建一个CNAME文件，注意没有后缀。写上你的域名。<br>注意，只要写进你自己的域名即可。如果带有www，那么以后访问的时候必须带有www完整的域名才可以访问，但如果不带有www，以后访问的时候带不带www都可以访问。所以建议，不要带有www。<br><img src="/uploads/i_17.png" alt="image"></p></li><li><p>点击保存。保存成功后运行hexo g、hexo d传到github上。这时候打开浏览器在地址栏输入你的个性化域名将会直接进入你自己搭建的网站。</p></li></ul><h3 id="个性化配置"><a href="#个性化配置" class="headerlink" title="个性化配置"></a>个性化配置</h3><h3 id="寻找图床"><a href="#寻找图床" class="headerlink" title="寻找图床"></a>寻找图床</h3>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/uploads/hexo.jpg&quot; alt=&quot;image&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="前端" scheme="https://litgod.net/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="Hexo" scheme="https://litgod.net/tags/Hexo/"/>
    
  </entry>
  
</feed>
