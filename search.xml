<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>浅谈 this、call、apply 和 bind</title>
    <url>/2020/01/19/%E5%85%B3%E4%BA%8E-this%E3%80%81call%E3%80%81apply-%E5%92%8C-bind-%E7%9A%84%E4%B8%80%E4%BA%9B%E7%90%86%E8%A7%A3/</url>
    <content><![CDATA[<p><img src="/uploads/i2_1.jpg" alt="image"></p>
<a id="more"></a>

<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这是一个前端面试特别容易考的考点，很多初学者在这个问题上都容易踩坑，包括我也是经常性蒙圈。所以这次我决定将他们梳理下来，加深自己的理解。如果有出错的地方，欢迎指正。</p>
<h1 id="this-是什么"><a href="#this-是什么" class="headerlink" title="this 是什么"></a>this 是什么</h1><p>this 关键字是 Javascript ES5 中最复杂的机制之一。<a href="http://es6.ruanyifeng.com/#README" target="_blank" rel="external nofollow noopener noreferrer">ES6</a> 中新增的箭头函数，很大程度上避免了使用 this 所产生的错误。但是在 ES5 中，有时候我们会错误的判断了 this 的指向。其实 this 的指向，始终坚持一个原理：<strong>this 永远指向最后调用它的那个对象</strong>，记住了这句话，this 的指向你已经了解一半了。</p>
<h1 id="this-的四种绑定方式"><a href="#this-的四种绑定方式" class="headerlink" title="this 的四种绑定方式"></a>this 的四种绑定方式</h1><p>想要了解 this 的指向，我们首先要了解 this 的四种绑定方式：<strong>隐式绑定、显示绑定、new 绑定、window 绑定</strong>。</p>
<h2 id="隐式绑定"><a href="#隐式绑定" class="headerlink" title="隐式绑定"></a>隐式绑定</h2><p>执行绑定的第一个也是最常见的规则为 <strong>隐式绑定</strong>，它80% 的情况下它会告诉你 this 指向的对象是什么。</p>
<p>我们先来看一个简单的例子：<br>例1:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const user = &#123;</span><br><span class="line">  name: &apos;Cherry&apos;,</span><br><span class="line">  age: 27,</span><br><span class="line">  getName() &#123;</span><br><span class="line">    alert(`Hello, my name is $&#123;this.name&#125;`)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">user.getName()</span><br></pre></td></tr></table></figure>

<p>如果你要调用 <strong>user</strong> 对象上的  <strong>getName</strong> 方法，你会用到点<code>.</code></p>
<p>这就是所谓隐式绑定，<strong>函数被调用时先看一看点号左侧</strong>。如果有“点”就查看“点”左侧的对象，这个对象就是 <strong>this</strong> 的引用。</p>
<p>在上面的例子中，<strong>user</strong> 在“点号左侧”意味着 <strong>this</strong> 引用了 <strong>user</strong> 对象。所以就好像 在 <strong>getName</strong> 方法的内部 <strong>JavaScript</strong> 解释器把 <strong>this</strong> 变成了 <strong>user</strong>。</p>
<p>例2:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const user = &#123;</span><br><span class="line">  name: &apos;Cherry&apos;,</span><br><span class="line">  age: 27,</span><br><span class="line">  getName() &#123;</span><br><span class="line">    alert(`Hello, my name is $&#123;this.name&#125;`)</span><br><span class="line">  &#125;,</span><br><span class="line">  mother: &#123;</span><br><span class="line">    name: &apos;Susan&apos;,</span><br><span class="line">    getName() &#123;</span><br><span class="line">      alert(`Hello, my name is $&#123;this.name&#125;`)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">user.getName()  // Cherry</span><br><span class="line">user.mother.getName()    // Susan</span><br></pre></td></tr></table></figure>

<p>如前所述，大约有 80% 的情况下在“点”的左侧都会有一个对象。这就是为什么在判断 this 指向时“查看点的左侧”是你要做的第一件事。但是，如果没有点呢？这就为我们引出了下一条规则：</p>
<h2 id="显示绑定"><a href="#显示绑定" class="headerlink" title="显示绑定"></a>显示绑定</h2><p>例3:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function getName () &#123;</span><br><span class="line">  alert(`Hello, my name is $&#123;this.name&#125;`)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const user = &#123;</span><br><span class="line">  name: &apos;Tyler&apos;,</span><br><span class="line">  age: 27,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在引出了一个问题，我们怎样能让 <strong>getName</strong> 方法调用的时候将 <strong>this</strong> 指向 <strong>user</strong> 对象？我们不能再像之前那样简单的使用 <strong>user.getName()</strong>，因为 <strong>user</strong> 并没有 <strong>getName</strong> 方法。在 <strong>JavaScript</strong> 中，每个函数都包含了一个能让你恰好解决这个问题的方法，这个方法的名字叫做 <strong>call、apply、bind</strong>。</p>
<p>用下面的代码可以在调用 <strong>getName</strong> 时用 <strong>user</strong> 做上下文。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">getName.call(user)</span><br></pre></td></tr></table></figure>

<p>这就是第 2 条规则的基础（显示绑定），因为我们明确地（使用 .call）指定了 this 的引用。第六章节有对 call、apply、bind 详细的介绍，这里就不过多赘述了。</p>
<h2 id="new-绑定"><a href="#new-绑定" class="headerlink" title="new 绑定"></a>new 绑定</h2><p>第三条判断 <strong>this</strong> 引用的规则是 <strong>new</strong> 绑定。每当用 <strong>new</strong> 调用函数时，<strong>JavaScript</strong> 解释器都会在底层创建一个全新的对象并把这个对象当做 <strong>this</strong>。</p>
<blockquote>
<p>这看起来就像创建了新的函数，但实际上 <strong>JavaScript</strong> 函数是重新创建的对象。</p>
</blockquote>
<p>例4:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function User (name, age) &#123;</span><br><span class="line">  /*</span><br><span class="line">    JavaScript 会在底层创建一个新对象 `this`，它会代理不在 User 原型链上的属性。</span><br><span class="line">    如果一个函数用 new 关键字调用，this 就会指向解释器创建的新对象。</span><br><span class="line">  */</span><br><span class="line"></span><br><span class="line">  this.name = name</span><br><span class="line">  this.age = age</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const me = new User(&apos;Cherry&apos;, 27)</span><br></pre></td></tr></table></figure>

<p>这就有要说另一个面试经典问题了：new 的过程。<br>这里就简单的来看一下 new 的过程吧：<br>伪代码表示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var a = new User(&quot;Qi&quot;,&quot;Cherry&quot;);</span><br><span class="line"></span><br><span class="line">new User&#123;</span><br><span class="line">  var object = &#123;&#125;;</span><br><span class="line">  object.__proto__ = User.prototype;</span><br><span class="line">  var result = User.call(object,&quot;Li&quot;,&quot;Cherry&quot;);</span><br><span class="line">  return typeof result === &apos;object&apos;? result : object;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>new</strong> 的过程：<br>1.创建一个空对象 object;<br>2.将新创建的空对象的隐式原型指向其构造函数的显示原型；<br>3.使用 call 改变 this 的指向；<br>4.如果无返回值或者返回一个非对象值，则将 object 返回作为新对象；如果返回值是一个新对象的话那么直接直接返回该对象。</p>
<p>所以我们可以看到，在 new 的过程中，我们是使用 call 改变了 this 的指向。</p>
<h2 id="window-绑定"><a href="#window-绑定" class="headerlink" title="window 绑定"></a>window 绑定</h2><p>我们先来看下面这个例子：<br>例5:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function getAge () &#123;</span><br><span class="line">  console.log(`My age is $&#123;this.age&#125;`)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const user = &#123;</span><br><span class="line">  name: &apos;Cherry&apos;,</span><br><span class="line">  age: 27,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>相信大家都知道为什么打印出来的是 <strong>My name is undefined</strong>，因为正如前面所说的，如果你想用 <strong>user</strong> 做上下文调用 <strong>getAge</strong>，你可以使用 <strong>.call</strong>、<strong>.apply</strong> 或 <strong>.bind</strong>。但如果我们没有用这些方法，而是直接和平时一样直接调用，<strong>JavaScript</strong> 会默认 <strong>this</strong> 指向 <strong>window</strong> 对象。但是 <strong>window</strong> 对象中并没有 <strong>name</strong> 属性，所以会打印 <strong>“My age is undefined“</strong>。</p>
<p>如果我们改成：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">age = 27</span><br><span class="line"></span><br><span class="line">function getAge () &#123;</span><br><span class="line">  console.log(`My age is $&#123;this.age&#125;`)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const user = &#123;</span><br><span class="line">  name: &apos;Cherry&apos;,</span><br><span class="line">  // age: 27,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这就是第 4 条规则为什么是 <strong>window</strong> 绑定 的原因。如果其它规则都没满足，<strong>JavaScript</strong> 就会默认 <strong>this</strong> 指向 <strong>window</strong> 对象。</p>
<blockquote>
<p>在 ES5 添加的 严格模式 中，JavaScript 不会默认 this 指向 window 对象，而会正确地把 this 保持为 undefined。</p>
</blockquote>
<p>例6:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&apos;use strict&apos;</span><br><span class="line"></span><br><span class="line">age = 27</span><br><span class="line"></span><br><span class="line">function sayAge () &#123;</span><br><span class="line">  console.log(`My age is $&#123;this.age&#125;`)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sayAge() // TypeError: Cannot read property &apos;age&apos; of undefined</span><br></pre></td></tr></table></figure>


<h1 id="this-的指向"><a href="#this-的指向" class="headerlink" title="this 的指向"></a>this 的指向</h1><p>前面讲了关于 this 的四种绑定方式，我们对于 this 的指向应该也有了一些自己的理解，还记得我们之前说的吗？<strong>this 永远指向最后调用它的那个对象，this 永远指向最后调用它的那个对象，this 永远指向最后调用它的那个对象。</strong>重要的事情说三遍。所以我们记好这句话看下面的例子：</p>
<p>例7:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var name = &quot;window&quot;;</span><br><span class="line">function fn() &#123;</span><br><span class="line">  var name = &quot;Cherry&quot;;</span><br><span class="line"></span><br><span class="line">  console.log(this.name);          // window</span><br><span class="line"></span><br><span class="line">  console.log(&quot;inner:&quot; + this);    // inner: Window</span><br><span class="line">&#125;</span><br><span class="line">fn();</span><br><span class="line">console.log(&quot;outer:&quot; + this)         // outer: Window</span><br></pre></td></tr></table></figure>
<p>我们看最后调用 <strong>fn</strong> 的地方 <code>fn();</code>，前面没有“点”，<strong>Javascript</strong> 调用的对象默认指向了全局对象 <strong>window</strong>，这就相当于是 <code>window.fn()；</code>所以根据刚刚的那句话“<strong>this 永远指向最后调用它的那个对象</strong>”，<strong>this</strong> 指向的就是 <strong>window</strong>。</p>
<blockquote>
<p>注意，这里我们没有使用严格模式，如果使用严格模式的话，全局对象就是 undefined，那么就会报错 Uncaught TypeError: Cannot read property ‘name’ of undefined。</p>
</blockquote>
<p>例8:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var name = &quot;window&quot;;</span><br><span class="line">var user = &#123;</span><br><span class="line">  name: &quot;Cherry&quot;,</span><br><span class="line">  fn: function () &#123;</span><br><span class="line">      console.log(this.name);      // Cherry</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">user.fn();</span><br></pre></td></tr></table></figure>

<p>根据上文所说，我们看到函数 <strong>fn</strong> 左侧有“点”，“点”的左侧是 <strong>user</strong>，所以 <strong>fn</strong> 是对象 <strong>user</strong> 调用的。所以打印的值就是 <strong>user</strong> 中的 <strong>name</strong> 的值。绑定规则是隐式绑定，是不是有一点清晰了呢~</p>
<p>我们再看下面这个例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var name = &quot;window&quot;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">function fnA()&#123;</span><br><span class="line">  var name = &quot;Cherry&quot;;</span><br><span class="line"></span><br><span class="line">  function fnB()&#123;</span><br><span class="line">    console.log(this.name);    // window </span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  //在A函数内部调用B函数</span><br><span class="line">  fnB();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//调用A函数</span><br><span class="line">fnA();</span><br></pre></td></tr></table></figure>
<p>在函数执行环境中使用 this 时,如果函数没有明显的作为非 window 对象的属性，而只是定义了函数，不管这个函数是不是定义在另一个函数中，这个函数中的 this 仍然表示 window 对象。</p>
<p>例9:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var name = &quot;window&quot;;</span><br><span class="line">var user = &#123;</span><br><span class="line">  name: &quot;Cherry&quot;,</span><br><span class="line">  fn: function () &#123;</span><br><span class="line">    console.log(this.name);      // Cherry</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">window.user.fn();</span><br></pre></td></tr></table></figure>
<p>这里打印 Cherry 的原因也是因为刚刚那句话“this 永远指向最后调用它的那个对象”，最后调用它的对象仍然是对象 user。</p>
<p>我们改动一下：</p>
<p>例10:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var name = &quot;window&quot;;</span><br><span class="line">var user = &#123;</span><br><span class="line">  // name: &quot;Cherry&quot;,</span><br><span class="line">  fn: function () &#123;</span><br><span class="line">    console.log(this.name);      // undefined</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">window.user.fn();</span><br></pre></td></tr></table></figure>

<p>这是因为调用 <strong>fn</strong> 的是 <strong>user</strong> 对象，也就是说 <strong>fn</strong> 的内部的 <strong>this</strong> 是对象 <strong>user</strong>，而对象 <strong>user</strong> 中并没有对 <strong>name</strong> 进行定义，所以 <strong>log</strong> 的 <strong>this.name</strong> 的值是 <strong>undefined</strong>。</p>
<p>这个例子还是说明了：<strong>this 永远指向最后调用它的那个对象</strong>，因为最后调用 <strong>fn</strong> 的对象是 <strong>user</strong>，所以就算 <strong>user</strong> 中没有 <strong>name</strong> 这个属性，也不会继续向上一个对象寻找 <strong>this.name</strong>，而是直接输出 <strong>undefined</strong>。</p>
<p>我们再来看一个比较坑的例子：<br>例11:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var name = &quot;window&quot;;</span><br><span class="line">var user = &#123;</span><br><span class="line">  name : null,</span><br><span class="line">  // name: &quot;Cherry&quot;,</span><br><span class="line">  fn : function () &#123;</span><br><span class="line">    console.log(this.name);      // window</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var f = user.fn;</span><br><span class="line">f();</span><br></pre></td></tr></table></figure>

<p>这里你可能会有疑问，为什么不是 Cherry？因为这里虽然将 <strong>user</strong> 对象的 <code>fn</code> 方法赋值给变量 <code>f</code> 了，但是<strong>没有调用</strong>，再接着跟我念这一句话：“<strong>this 永远指向最后调用它的那个对象</strong>”，由于刚刚的 <code>f</code> 并没有调用，所以 <code>fn()</code> 最后仍然是被 <strong>window</strong> 调用的。所以 <strong>this</strong> 指向的也就是 <strong>window</strong>。</p>
<p>由以上五个例子我们可以看出，this 的指向并不是在创建的时候就可以确定的，在 es5 中，<strong>this永远指向最后调用它的那个对象。</strong></p>
<h1 id="如何改变-this-的指向"><a href="#如何改变-this-的指向" class="headerlink" title="如何改变 this 的指向"></a>如何改变 this 的指向</h1><p>改变 this 的指向我总结有以下几种方法：</p>
<ul>
<li>使用 ES6 的箭头函数</li>
<li>在函数内部使用 _this = this</li>
<li>使用 apply、call、bind</li>
<li>new 实例化一个对象</li>
</ul>
<p>例12:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var name = &quot;window&quot;;</span><br><span class="line"></span><br><span class="line">var user = &#123;</span><br><span class="line">  name : &quot;Cherry&quot;,</span><br><span class="line"></span><br><span class="line">  func1: function() &#123;</span><br><span class="line">    console.log(this.name)     </span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  func2: function() &#123;</span><br><span class="line">    setTimeout(function () &#123;</span><br><span class="line">      this.func1()</span><br><span class="line">    &#125;,100);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">user.func2()     // this.func1 is not a function</span><br></pre></td></tr></table></figure>
<p>我们逐一细说一下这个例子：<code>func2()</code>是被 <strong>user</strong>调用的，所以<code>func2</code>中的 <strong>this</strong> 应该指向 <strong>user</strong>。但是<code>func2</code>中又调用了 <strong>window</strong> 中的 <strong>setTimeout</strong> 方法。所以在 <strong>setTimeout</strong> 方法中的 <strong>this</strong> 指向的是后调用它的对象 <strong>window</strong>。但是在 <strong>window</strong> 中并没有 <strong>func1</strong> 函数。所以抛出错误：this.func1 is not a function。</p>
<p>如果我们想正确的调用 <strong>user</strong> 中的 <code>func1()</code>，应该怎么做呢？我们把这个例子作为 demo 进行改造。</p>
<h2 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h2><p>众所周知，ES6 的箭头函数是可以避免 ES5 中使用 this 的坑的。箭头函数的 this 始终指向函数定义时的 this，而非执行时。箭头函数需要记着这句话：“<strong>箭头函数中没有 this 绑定，必须通过查找作用域链来决定其值，如果箭头函数被非箭头函数包含，则 this 绑定的是最近一层非箭头函数的 this，否则，this 为 undefined</strong>”。</p>
<p>例13:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var name = &quot;window&quot;;</span><br><span class="line"></span><br><span class="line">var user = &#123;</span><br><span class="line">  name : &quot;Cherry&quot;,</span><br><span class="line"></span><br><span class="line">  func1: function () &#123;</span><br><span class="line">    console.log(this.name)     </span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  func2: function () &#123;</span><br><span class="line">    setTimeout( () =&gt; &#123;</span><br><span class="line">        this.func1()</span><br><span class="line">    &#125;,100);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">user.func2()     // Cherry</span><br></pre></td></tr></table></figure>
<h2 id="在函数内部使用-this-this"><a href="#在函数内部使用-this-this" class="headerlink" title="在函数内部使用 _this = this"></a>在函数内部使用 _this = this</h2><p>如果不使用 ES6，那么这种方式应该是最简单的不会出错的方式了，我们是先将调用这个函数的对象保存在变量 _this 中，然后在函数中都使用这个 _this，这样 _this 就不会改变了。</p>
<p>例14:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var name = &quot;window&quot;;</span><br><span class="line"></span><br><span class="line">var user = &#123;</span><br><span class="line"></span><br><span class="line">  name : &quot;Cherry&quot;,</span><br><span class="line"></span><br><span class="line">  func1: function () &#123;</span><br><span class="line">    console.log(this.name)     </span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  func2: function () &#123;</span><br><span class="line">    var _this = this;</span><br><span class="line">    setTimeout( function() &#123;</span><br><span class="line">      _this.func1()</span><br><span class="line">    &#125;,100);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">user.func2()       // Cherry</span><br></pre></td></tr></table></figure>

<p>这个例子中，在 func2 中，首先设置 var _this = this;，这里的 <strong>this</strong> 是调用 <code>func2</code> 的对象 <strong>user</strong>，为了防止在 <code>func2</code> 中的 <strong>setTimeout</strong> 被 <strong>window</strong> 调用而导致的在 <strong>setTimeout</strong> 中的 <strong>this</strong> 为 <strong>window</strong>。我们将 <strong>this</strong>(指向变量 user) 赋值给一个变量 <strong>_this</strong>，这样，在 <code>func2</code> 中我们使用 <strong>_this</strong> 就是指向对象 <strong>user</strong> 了。</p>
<h2 id="使用-apply、call、bind"><a href="#使用-apply、call、bind" class="headerlink" title="使用 apply、call、bind"></a>使用 apply、call、bind</h2><p>使用 apply、call、bind 函数也是可以改变 this 的指向的，原理稍后再讲，我们先来看一下是怎么实现的：</p>
<h3 id="使用-apply"><a href="#使用-apply" class="headerlink" title="使用 apply()"></a>使用 apply()</h3><p>例15:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var user = &#123;</span><br><span class="line">  name: &quot;Cherry&quot;,</span><br><span class="line"></span><br><span class="line">  func1: function() &#123;</span><br><span class="line">    console.log(this.name)</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  func2: function() &#123;</span><br><span class="line">    setTimeout(function () &#123;</span><br><span class="line">      this.func1()</span><br><span class="line">    &#125;.apply(user), 100);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">user.func2()            // Cherry</span><br></pre></td></tr></table></figure>

<h3 id="使用-call"><a href="#使用-call" class="headerlink" title="使用 call()"></a>使用 call()</h3><p>例16:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var user = &#123;</span><br><span class="line">  name: &quot;Cherry&quot;,</span><br><span class="line"></span><br><span class="line">  func1: function() &#123;</span><br><span class="line">    console.log(this.name)</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  func2: function() &#123;</span><br><span class="line">    setTimeout(function () &#123;</span><br><span class="line">      this.func1()</span><br><span class="line">    &#125;.call(user), 100);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">user.func2()            // Cherry</span><br></pre></td></tr></table></figure>

<h3 id="使用-bind"><a href="#使用-bind" class="headerlink" title="使用 bind()"></a>使用 bind()</h3><p>例17:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var user = &#123;</span><br><span class="line">  name: &quot;Cherry&quot;,</span><br><span class="line"></span><br><span class="line">  func1: function() &#123;</span><br><span class="line">    console.log(this.name)</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  func2: function() &#123;</span><br><span class="line">    setTimeout(function () &#123;</span><br><span class="line">      this.func1()</span><br><span class="line">    &#125;.bind(user)(), 100);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">user.func2()            // Cherry</span><br></pre></td></tr></table></figure>

<h1 id="apply、call、bind-的区别"><a href="#apply、call、bind-的区别" class="headerlink" title="apply、call、bind 的区别"></a>apply、call、bind 的区别</h1><p>刚刚我们已经介绍了 apply、call、bind 都是可以改变 this 的指向的，但是这三个函数稍有不同。</p>
<p>在 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/apply" target="_blank" rel="external nofollow noopener noreferrer">MDN</a> 中定义 apply 如下；</p>
<blockquote>
<p>apply() 方法调用一个函数, 其具有一个指定的this值，以及作为一个数组（或类似数组的对象）提供的参数</p>
</blockquote>
<p>语法：</p>
<blockquote>
<p>fun.apply(thisArg, [argsArray])</p>
</blockquote>
<ul>
<li>thisArg：在 fun 函数运行时指定的 this 值。需要注意的是，指定的 this 值并不一定是该函数执行时真正的 this 值，如果这个函数处于非严格模式下，则指定为 null 或 undefined 时会自动指向全局对象（浏览器中就是window对象），同时值为原始值（数字，字符串，布尔值）的 this 会指向该原始值的自动包装对象。</li>
<li>argsArray：一个数组或者类数组对象，其中的数组元素将作为单独的参数传给 fun 函数。如果该参数的值为null 或 undefined，则表示不需要传入任何参数。从ECMAScript 5 开始可以使用类数组对象。浏览器兼容性请参阅本文底部内容。</li>
</ul>
<h2 id="apply-和-call-的区别"><a href="#apply-和-call-的区别" class="headerlink" title="apply 和 call 的区别"></a>apply 和 call 的区别</h2><p>其实 apply 和 call 基本类似，他们的区别只是传入的参数不同。</p>
<p>call 的语法为: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fun.call(thisArg[, arg1[, arg2[, ...]]])</span><br></pre></td></tr></table></figure>

<p>所以 apply 和 call 的区别是 call 方法接受的是若干个参数列表，而 apply 接收的是一个包含多个参数的数组。</p>
<p>例18:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var user =&#123;</span><br><span class="line">  name: &quot;Cherry&quot;,</span><br><span class="line">  fn: function(a,b) &#123;</span><br><span class="line">    console.log(a + b)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var newUser = user.fn;</span><br><span class="line">newUser.apply(user,[1,2])     // 3</span><br></pre></td></tr></table></figure>

<p>例19:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var user =&#123;</span><br><span class="line">  name: &quot;Cherry&quot;,</span><br><span class="line">  fn: function(a,b) &#123;</span><br><span class="line">    console.log(a + b)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var newUser =user.fn;</span><br><span class="line">newUser.call(user, 1, 2)       // 3</span><br></pre></td></tr></table></figure>
<h2 id="bind-和-apply、call-区别"><a href="#bind-和-apply、call-区别" class="headerlink" title="bind 和 apply、call 区别"></a>bind 和 apply、call 区别</h2><p>我们先来将刚刚的例子使用 bind 试一下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var user =&#123;</span><br><span class="line">  name: &quot;Cherry&quot;,</span><br><span class="line">  fn: function(a,b) &#123;</span><br><span class="line">    console.log(a + b)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var newUser = user.fn;</span><br><span class="line">nreUser.bind(user,1,2)</span><br></pre></td></tr></table></figure>

<p>我们会发现并没有输出，这是为什么呢，我们来看一下 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/bind" target="_blank" rel="external nofollow noopener noreferrer">MDN</a> 上的文档说明：</p>
<blockquote>
<p>bind()方法创建一个新的函数, 当被调用时，将其this关键字设置为提供的值，在调用新函数时，在任何提供之前提供一个给定的参数序列。</p>
</blockquote>
<p>所以我们可以看出，bind 是创建一个新的函数，我们必须要手动去调用:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var user =&#123;</span><br><span class="line">  name: &quot;Cherry&quot;,</span><br><span class="line">  fn: function (a,b) &#123;</span><br><span class="line">    console.log( a + b)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var newUser = user.fn;</span><br><span class="line">newUser.bind(user,1,2)()           // 3</span><br></pre></td></tr></table></figure>

<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>每当在函数内部看到 this 关键字时，我们可以用以下步骤判断 this 的指向。</p>
<p>1.查看函数在哪被调用。<br>2.点左侧有没有对象？如果有，它就是 “this” 的引用。如果没有，继续第 3 步。<br>3.该函数是不是用 “call”、“apply” 或者 “bind” 调用的？如果是，它会显式地指明 “this” 的引用。如果不是，继续第 4 步。<br>4.该函数是不是用 “new” 调用的？如果是，“this” 指向的就是 JavaScript 解释器新创建的对象。如果不是，继续第 5 步。<br>5.是否在“严格模式”下？如果是，“this” 就是 undefined，如果不是，继续第 6 步。<br>6.JavaScript 很奇怪，“this” 会指向 “window” 对象。</p>
<p>另外切记：this<strong>永远</strong>指向最后调用它的那个对象。this永远指向<strong>最后调用</strong>它的那个对象。this永远指向最后调用它的<strong>那个对象</strong>。</p>
]]></content>
  </entry>
  <entry>
    <title>超详细的Github+Hexo搭建教程</title>
    <url>/2019/10/31/%E8%B6%85%E8%AF%A6%E7%BB%86%E7%9A%84Github-Hexo%E6%90%AD%E5%BB%BA%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<p><img src="/uploads/hexo.jpg" alt="image"></p>
<a id="more"></a>

<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>不管你是程序猿（媛），产品经理，设计师，运维工程师…还是从事其他职业，应该都想拥有一个属于自己的个人博客网站吧。如果你是，那么请跟随目录，搭建属于你的个人博客吧!一起来技术分享，记录生活…</p>
<h2 id="Hexo-是什么"><a href="#Hexo-是什么" class="headerlink" title="Hexo 是什么"></a>Hexo 是什么</h2><p><a href="https://hexo.io" target="_blank" rel="external nofollow noopener noreferrer">Hexo</a> 是一个基于 <a href="https://nodejs.org/en" target="_blank" rel="external nofollow noopener noreferrer">Node.js</a>的快速，简单月功能强大的博客框架。可以使用简单的命令生成静态网页，并托管到 Github 上。<br>#TODO</p>
<h2 id="来搭建属于你的个人博客吧～"><a href="#来搭建属于你的个人博客吧～" class="headerlink" title="来搭建属于你的个人博客吧～"></a>来搭建属于你的个人博客吧～</h2><h3 id="Gihub-创建个人仓库"><a href="#Gihub-创建个人仓库" class="headerlink" title="Gihub 创建个人仓库"></a>Gihub 创建个人仓库</h3><ul>
<li><p>首先先登录到 <a href="https://github.com" target="_blank" rel="external nofollow noopener noreferrer">Github</a>。如果没有个人账号，先进行注册，注册完成后，点击登录进入 Github。</p>
</li>
<li><p>点击绿色的 <strong>New</strong> 按钮新建一个仓库，将仓库名称命为： 用户名.github.io，例如：qiruohan.github.io，这个写法是固定的。<br><img src="/uploads/i_1.jpg" alt="image"><br><img src="/uploads/i_2.jpg" alt="image"></p>
</li>
<li><p>注意：仓库名称要和你的用户名保持一致，后缀.github.io 的作用是 Github 识别到.github.io 后缀就会为你自动开启<a href="https://pages.github.com/" target="_blank" rel="external nofollow noopener noreferrer">Github Page</a>，作为你个人博客的仓库。</p>
</li>
</ul>
<p>然后项目就建成了，点击Settings，向下拉到最后有个GitHub Pages，点击Choose a theme可以选择一个主题。然后点击那个链接，就会出现自己的网页啦～</p>
<h3 id="安装-Node-js"><a href="#安装-Node-js" class="headerlink" title="安装 Node.js"></a>安装 Node.js</h3><p>Node.js 是基于 <a href="https://v8.dev/" target="_blank" rel="external nofollow noopener noreferrer">Chrome V8 JavaScript 引擎</a> 构建的语言，是一项服务器端技术。<br>下载地址：<a href="https://nodejs.org/en/download/" target="_blank" rel="external nofollow noopener noreferrer">Node.js | Download</a>，下载当前操作系统的安装包，安装选项全部默认。注意下载的安装包中已经包含了环境变量以及 <a href="https://www.npmjs.com/" target="_blank" rel="external nofollow noopener noreferrer">npm</a>，所以安装完安装包后无需另外再下载 npm。</p>
<p>检测 Node.js 是否安装成功，在命令行中输入：<strong>node -v</strong><br><img src="/uploads/i_3.png" alt="image"></p>
<p>检测 npm 是否安装成功，在命令行中输入：<strong>npm -v</strong><br><img src="/uploads/i_4.png" alt="image"></p>
<p>显示版本号，那么就说明 node.js 安装成功了。</p>
<h3 id="安装-Git"><a href="#安装-Git" class="headerlink" title="安装 Git"></a>安装 Git</h3><p><a href="https://git-scm.com/" target="_blank" rel="external nofollow noopener noreferrer">Git</a> 是一个开源的分布式版本控制系统，旨在快速高效地处理从小型到大型项目的所有内容。具有便捷的创建本地分支，创建暂存区域，处理多个工作流等功能。简单来说，使用 Git 可以把本地文件同步到 Github 上，完成多人多空间的便捷式管理。</p>
<p><strong>Windows 下</strong>安装下载地址：<a href="https://git-scm.com/download/" target="_blank" rel="external nofollow noopener noreferrer">Git | Downloads</a>，安装选项还是全部默认，安装完成后在命令行中输入 <strong>git –version</strong> 验证是否安装成功。<br><img src="/uploads/i_5.png" alt="image"><br>显示版本号，那么就说明 git 安装成功了。安装成功后，将你的Git与GitHub帐号绑定，鼠标右击打开Git Bash，设置user.name和user.email配置信息。<br>之后移步到 mac 下安装流程的<strong>第三步：设置github的 username 和 email</strong>，做接来下的操作。</p>
<p><strong>Mac 下安装</strong>：</p>
<ul>
<li><p>如果未安 homebrew，需要先安装 homebrew</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;</span><br></pre></td></tr></table></figure>
</li>
<li><p>安装 git</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">brew install git</span><br></pre></td></tr></table></figure>
</li>
<li><p>检查 git 是否安装成功</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git --version</span><br></pre></td></tr></table></figure>
</li>
<li><p>安装成功后，先设置github的 username 和 email（github 在每次提交的时候都会记录他们）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git config --global user.name &quot;你的GitHub用户名&quot;</span><br><span class="line">git config --global user.email &quot;你的GitHub注册邮箱&quot;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用终端命令创建 ssh key</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;你的GitHub注册邮箱&quot;</span><br></pre></td></tr></table></figure>
<p>然后直接三个回车即可，默认不需要设置密码<br>然后找到生成的.ssh的文件夹中的id_rsa.pub密钥，将内容全部复制</p>
</li>
<li><p>打开 <a href="https://github.com/settings/keys" target="_blank" rel="external nofollow noopener noreferrer">GitHub_Settings_keys</a> 页面，新建new SSH Key<br><img src="/uploads/i_10.png" alt="image"></p>
</li>
</ul>
<p>Title为标题，任意填即可，将刚刚复制的id_rsa.pub内容粘贴进去，最后点击Add SSH key。</p>
<ul>
<li>在终端检测GitHub公钥设置是否成功，输入 ssh <a href="mailto:git@github.com" target="_blank" rel="external nofollow noopener noreferrer">git@github.com</a>。<br><img src="/uploads/i_11.png" alt="image"></li>
</ul>
<p>如上则说明成功。</p>
<p>注意：这里之所以设置GitHub密钥原因是，通过非对称加密的公钥与私钥来完成加密，公钥放置在GitHub上，私钥放置在自己的电脑里。GitHub要求每次推送代码都是合法用户，所以每次推送都需要输入账号密码验证推送用户是否是合法用户，为了省去每次输入密码的步骤，采用了ssh，当你推送的时候，git就会匹配你的私钥跟GitHub上面的公钥是否是配对的，若是匹配就认为你是合法用户，则允许推送。这样可以保证每次的推送都是正确合法的。</p>
<h3 id="安装-Hexo"><a href="#安装-Hexo" class="headerlink" title="安装 Hexo"></a>安装 Hexo</h3><p>Hexo 就是我们搭建个人博客所使用的框架，我们需要在合适的地方先创建一个文件夹，用来存放自己的博客文件，例如我命名为blog2。</p>
<p>使用命令行进入到该目录下，输入 <code>npm i hexo-cli -g</code> 安装 Hexo，安装成功后，会显示安装所使用的总时长。<br><img src="/uploads/i_6.png" alt="image"></p>
<p>安装完成后，初始化我们的博客，输入 <code>hexo init blog</code>。<br>注意：这里的命令都作用在刚刚创建的 blog2 文件夹下。<br><img src="/uploads/i_7.png" alt="image"></p>
<p>初始化时间可能会比较长，耐心等待…<br><img src="/uploads/i_8.png" alt="image"></p>
<p>初始化完成后，会发现 blog2 下又新增了一个文件夹，名为 blog，与 <code>hexo init</code> 后面输入的文件名同名。我们进入新创建的文件夹 blog 下，输入以下三条命名来检测一下我们的网站雏形</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo new test</span><br><span class="line"></span><br><span class="line">hexo g</span><br><span class="line"></span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure>
<p><img src="/uploads/i_9.png" alt="image"></p>
<p>到这里，我们的个人博客就搭建完成啦！并且已经写出了我们的第一篇文章～</p>
<h3 id="hexo-常用命令"><a href="#hexo-常用命令" class="headerlink" title="hexo 常用命令"></a>hexo 常用命令</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.安装 Hexo</span><br><span class="line">  npm install hexo -g</span><br><span class="line">2.升级 Hexo</span><br><span class="line">  npm update hexo -g</span><br><span class="line">3.初始化博客</span><br><span class="line">  hexo init &quot;博客站点&quot;</span><br><span class="line">4.新建文章</span><br><span class="line">  hexo n &quot;我的博客&quot;  或  hexo new &quot;我的博客&quot; </span><br><span class="line">5.生成博客</span><br><span class="line">  hexo g  或 hexo generate</span><br><span class="line">6.启动服务</span><br><span class="line">  hexo s  或  hexo server</span><br><span class="line">7.部署博客</span><br><span class="line">  hexo d  或  hexo deploy</span><br><span class="line">8.更改端口</span><br><span class="line">  hexo server -p 5000</span><br><span class="line">9.自定义 IP</span><br><span class="line">  hexo server -i 192.168.1.1</span><br><span class="line">10.清除缓存，若是网页正常情况下可以忽略这条命令</span><br><span class="line">  hexo clean</span><br><span class="line">11.新建页面</span><br><span class="line">  hexo new page xxx</span><br></pre></td></tr></table></figure>
<h3 id="推送博客站点"><a href="#推送博客站点" class="headerlink" title="推送博客站点"></a>推送博客站点</h3><p>上图只是本地的预览，如果想让大家都看到你的博客，就得把项目放在公网上被大家访问。打开博客根目录下的_config.yml文件，这是博客的配置文件，在这里你可以修改与博客相关的各种信息。这个文件称之为<strong>站点配置文件</strong>。<br><img src="/uploads/i_12.png" alt="image"></p>
<p>修改最后一行的配置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: https://github.com/qiruohan/qiruohan.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure>
<p>repository修改为你自己的github项目地址。</p>
<p>这里其实就是给 hexo d 命令做相应的配置，让 hexo 知道要把你的博客部署在哪个位置，我们需要把项目部署到我们自己的GitHub的仓库里。</p>
<p>安装Git部署插件，输入命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>

<p>这时，我们分别输入三条命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo clean </span><br><span class="line">hexo g </span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure>
<p>打开浏览器，在地址栏输入你的放置个人网站的仓库路径，即 xxxx.github.io, 比如我的：qiruohan.github.io， 你就会发现你的博客已经上线了，可以在网络上被访问了。</p>
<h3 id="更换主题"><a href="#更换主题" class="headerlink" title="更换主题"></a>更换主题</h3><p>如果你不喜欢 Hexo 的默认主题，可以更换主题，hexo主题有很多，你可以从网上找到很多很好看的主题，每个主题也都有自己的安装教程，你可以试着看一看。</p>
<p>我这里使用的主题是<a href="https://theme-next.iissnan.com/" target="_blank" rel="external nofollow noopener noreferrer">nexT</a>，所以我说一下我的安装配置吧～</p>
<ul>
<li><p>安装 nexT 主题，通过 git 命令将 nexT 克隆下来， 在博客站点目录下（我的是blog），使用 git clone 命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/theme-next/hexo-theme-next themes/next</span><br></pre></td></tr></table></figure>
</li>
<li><p>等待克隆完毕，找到 themes 文件夹下的 next 文件， 这就是我们刚刚克隆下来的主题了。<br><img src="/uploads/i_13.png" alt="image"></p>
</li>
<li><p>返回根目录，找到我们的站点文件_config.yml，打开并修改里面的 theme 配置以使我们刚刚克隆下来的主题生效。</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">theme: next</span><br></pre></td></tr></table></figure>

<p>修改theme: landscape为next，注意theme和next之间要有空格，否则无效。</p>
<p>正确设置好后，我们更换的主题就生效啦～每个主题都可以有自己个性化的配置，可以打开主题的_config.yml配置文件（注意不是站点配置文件），可以按照你的想法做一些个性化的配置，之后再次部署网站，hexo clean、hexo g、hexo d，查看效果。选择其他主题，按照上述过程即可实现。</p>
<h3 id="发布文章"><a href="#发布文章" class="headerlink" title="发布文章"></a>发布文章</h3><p>1.文章头设置</p>
<h3 id="MarkDown-语法"><a href="#MarkDown-语法" class="headerlink" title="MarkDown 语法"></a>MarkDown 语法</h3><p>Markdown是一种可以使用普通文本编辑器编写的标记语言，通过简单的标记语法，具体语法参看：<a href="https://www.appinn.com/markdown/" target="_blank" rel="external nofollow noopener noreferrer">Markdown 语法说明(简体中文版)</a> 可以说十分钟就可以入门，非常简单发方便。当然，选择一个好的Markdown编辑器也是非常重要的，mac版推荐使用 MacDown 或者直接使用 VsCode 编写 Markdown 文件， 非常方便。</p>
<h3 id="绑定域名"><a href="#绑定域名" class="headerlink" title="绑定域名"></a>绑定域名</h3><p>现在默认的域名还是xxx.github.io，而如果我们想使用个性化的域名，就需要绑定我们自己的域名，首先你需要购买一个域名，XX云都能买，国内主流的域名代理厂商也就阿里云和腾讯云。下面给大家演示阿里云的相关配置：</p>
<ul>
<li>登录阿里云，进入管理控制台的域名列表，找到你的个性化域名，进入解析</li>
</ul>
<p><img src="/uploads/i_14.png" alt="image"></p>
<ul>
<li>添加解析</li>
</ul>
<p><img src="/uploads/i_15.png" alt="image"></p>
<p>一共包括两条解析记录，记录类型都是CNAME，CNAME的记录值是：你的用户名.github.io，这里千万别弄错了。</p>
<ul>
<li>登录GitHub，进入之前创建的仓库，点击settings，设置Custom domain，输入你的域名，点击保存。<br><img src="/uploads/i_16.png" alt="image"></li>
</ul>
<p>注意：如果你把 Enforce HTTPS 钩上，github 会自动帮你升级为 https 的哦～</p>
<ul>
<li><p>这时候你的项目根目录应该会出现一个名为CNAME的文件了。如果没有的话，打开你本地博客/source目录，手动创建一个CNAME文件，注意没有后缀。写上你的域名。<br>注意，只要写进你自己的域名即可。如果带有www，那么以后访问的时候必须带有www完整的域名才可以访问，但如果不带有www，以后访问的时候带不带www都可以访问。所以建议，不要带有www。<br><img src="/uploads/i_17.png" alt="image"></p>
</li>
<li><p>点击保存。保存成功后运行hexo g、hexo d传到github上。这时候打开浏览器在地址栏输入你的个性化域名将会直接进入你自己搭建的网站。</p>
</li>
</ul>
<h3 id="个性化配置"><a href="#个性化配置" class="headerlink" title="个性化配置"></a>个性化配置</h3><h3 id="寻找图床"><a href="#寻找图床" class="headerlink" title="寻找图床"></a>寻找图床</h3>]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
</search>
